import pygame
import random
import math
from enum import Enum, auto
from dataclasses import dataclass
from typing import List, Dict, Tuple
from collections import defaultdict
import logging
import traceback

# Initialize logging
logging.basicConfig(
    filename='empire_at_war_debug.log',
    level=logging.DEBUG,
    format='%(asctime)s - %(levelname)s - %(message)s'
)

# Initialize pygame
try:
    pygame.init()
    pygame.mixer.init()  # For sound later
    logging.info("Pygame initialized successfully")
except Exception as e:
    logging.critical(f"Failed to initialize pygame: {str(e)}")
    raise SystemExit("Failed to initialize pygame")

# Game constants
SCREEN_WIDTH = 1280
SCREEN_HEIGHT = 720
FPS = 60
GALACTIC_DAY_DURATION = 30.0  # 30 seconds = 1 galactic day
PRODUCTION_SPEED_MULTIPLIER = 20  # 5x faster production

# Tactical battle map size (5x larger than before)
BATTLE_WIDTH = SCREEN_WIDTH * 5
BATTLE_HEIGHT = SCREEN_HEIGHT * 5

# Colors
BLACK = (0, 0, 0)
WHITE = (255, 255, 255)
RED = (255, 0, 0)
BLUE = (0, 0, 255)
GREEN = (0, 255, 0)
YELLOW = (255, 255, 0)
ORANGE = (255, 165, 0)
PURPLE = (128, 0, 128)
DARK_BLUE = (0, 0, 100)
SPACE_COLOR = (5, 5, 25)
IMPERIAL_GRAY = (150, 150, 150)
LIGHT_BLUE = (100, 100, 255)
DARK_RED = (150, 0, 0)
GOLD = (255, 215, 0)

# Star Destroyer specific colors
GRAY = (150, 150, 150)
DARK_GRAY = (100, 100, 100)
LIGHT_GRAY = (200, 200, 200)
BRIDGE_GRAY = (125, 125, 125)

# Debug settings
DEBUG_MODE = True
SHOW_FPS = True
VALIDATE_UNITS_EVERY = 60  # frames


# ========================
#       Game States
# ========================
class GameState(Enum):
    GALACTIC_MAP = auto()
    TACTICAL_BATTLE = auto()
    VICTORY = auto()
    DEFEAT = auto()


# ========================
#       Unit System
# ========================
class UnitType(Enum):
    FIGHTER = auto()
    CRUISER = auto()
    CAPITAL_SHIP = auto()
    BOMBER = auto()
    SPACE_STATION = auto()
    RESEARCH_STATION = auto()
    TRADE_STATION = auto()  # New economic station


@dataclass
class UnitTemplate:
    name: str
    cost: int
    build_time: float  # in seconds
    strength: int
    projectile_color: Tuple[int, int, int]
    projectile_speed: float
    projectile_size: int
    is_station: bool = False
    is_research_station: bool = False
    is_trade_station: bool = False  # New property for trade stations


UNIT_TEMPLATES: Dict[UnitType, UnitTemplate] = {
    UnitType.FIGHTER: UnitTemplate("TIE Fighter", 100, 5.0 / PRODUCTION_SPEED_MULTIPLIER, 1, (255, 50, 50), 8.0, 3),
    UnitType.CRUISER: UnitTemplate("Victory Cruiser", 250, 10.0 / PRODUCTION_SPEED_MULTIPLIER, 3, (255, 100, 0), 6.0,
                                   5),
    UnitType.CAPITAL_SHIP: UnitTemplate("Star Destroyer", 500, 20.0 / PRODUCTION_SPEED_MULTIPLIER, 10, (255, 255, 0),
                                        4.0, 8),
    UnitType.BOMBER: UnitTemplate("TIE Bomber", 150, 7.0 / PRODUCTION_SPEED_MULTIPLIER, 2, (255, 150, 0), 7.0, 4),
    UnitType.SPACE_STATION: UnitTemplate("Space Station", 1000, 30.0 / PRODUCTION_SPEED_MULTIPLIER, 2, (255, 0, 255),
                                         3.0, 10, True),
    UnitType.RESEARCH_STATION: UnitTemplate("Research Station", 1500, 40.0 / PRODUCTION_SPEED_MULTIPLIER, 1,
                                            (0, 200, 255), 2.0, 8, True, True),
    UnitType.TRADE_STATION: UnitTemplate("Trade Station", 1200, 35.0 / PRODUCTION_SPEED_MULTIPLIER, 0,
                                         (0, 255, 0), 0, 0, True, False, True)  # New trade station
}


# ========================
#       Tech Tree
# ========================
class TechTree:
    def __init__(self):
        self.tech_levels = {
            "fighters": 1,
            "bombers": 0,
            "cruisers": 0,
            "capital_ships": 0,
            "stations": 1,
            "research_station": 1,
            "trade_station": 1  # New tech
        }
        self.research_progress = {
            "fighters": 0,
            "bombers": 0,
            "cruisers": 0,
            "capital_ships": 0,
            "stations": 0,
            "research_station": 0,
            "trade_station": 0  # New tech
        }
        self.research_costs = {
            "fighters": 500,
            "bombers": 750,
            "cruisers": 1000,
            "capital_ships": 1500,
            "stations": 2000,
            "research_station": 1500,
            "trade_station": 1800  # New tech
        }
        self.research_requirements = {
            "fighters": None,
            "bombers": "research_station",
            "cruisers": "research_station",
            "capital_ships": "research_station",
            "stations": None,
            "research_station": None,
            "trade_station": "research_station"  # Requires research station
        }
        self.tech_to_unit = {
            "fighters": UnitType.FIGHTER,
            "bombers": UnitType.BOMBER,
            "cruisers": UnitType.CRUISER,
            "capital_ships": UnitType.CAPITAL_SHIP,
            "stations": UnitType.SPACE_STATION,
            "research_station": UnitType.RESEARCH_STATION,
            "trade_station": UnitType.TRADE_STATION  # New mapping
        }

    def can_build(self, unit_type: UnitType) -> bool:
        """Check if player can build a unit based on tech level"""
        try:
            if unit_type == UnitType.FIGHTER:
                return self.tech_levels["fighters"] >= 1
            elif unit_type == UnitType.BOMBER:
                return self.tech_levels["bombers"] >= 1
            elif unit_type == UnitType.CRUISER:
                return self.tech_levels["cruisers"] >= 1
            elif unit_type == UnitType.CAPITAL_SHIP:
                return self.tech_levels["capital_ships"] >= 1
            elif unit_type == UnitType.SPACE_STATION:
                return True
            elif unit_type == UnitType.RESEARCH_STATION:
                return True
            elif unit_type == UnitType.TRADE_STATION:
                return self.tech_levels["trade_station"] >= 1
            return False
        except KeyError as e:
            logging.error(f"TechTree.can_build error: {str(e)}")
            return False

    def can_research(self, tech: str) -> bool:
        """Check if player can research a tech"""
        try:
            requirement = self.research_requirements[tech]
            if requirement is None:
                return True
            return self.tech_levels[requirement] >= 1
        except KeyError as e:
            logging.error(f"TechTree.can_research error: {str(e)}")
            return False

    def start_research(self, tech: str, resources: int) -> bool:
        """Start researching a tech if possible"""
        try:
            if (tech in self.research_progress and
                    self.research_progress[tech] == 0 and
                    self.can_research(tech) and
                    resources >= self.research_costs[tech]):
                self.research_progress[tech] = 1
                logging.info(f"Started researching {tech}")
                return True
            return False
        except Exception as e:
            logging.error(f"TechTree.start_research error: {str(e)}")
            return False

    def update_research(self, dt: float):
        """Update research progress (now 5x faster)"""
        try:
            for tech, progress in self.research_progress.items():
                if progress > 0 and progress < 100:
                    self.research_progress[tech] = min(100, progress + dt * 25)  # 25% per second (5x faster)
                    if self.research_progress[tech] == 100:
                        self.tech_levels[tech] += 1
                        self.research_progress[tech] = 0
                        logging.info(f"Completed research on {tech}")
        except Exception as e:
            logging.error(f"TechTree.update_research error: {str(e)}")


class Projectile:
    def __init__(self, x: float, y: float, target_x: float, target_y: float,
                 damage: int, speed: float, size: int, color: Tuple[int, int, int], owner: int,
                 is_anti_fighter: bool = False, is_missile: bool = False):
        try:
            self.x = x
            self.y = y
            self.target_x = target_x
            self.target_y = target_y
            self.damage = damage
            self.speed = speed
            self.size = size
            self.color = color
            self.owner = owner
            self.is_anti_fighter = is_anti_fighter
            self.is_missile = is_missile
            self.health = 5 if is_missile else 1  # Missiles can be shot down

            # Calculate direction
            dx = target_x - x
            dy = target_y - y
            dist = max(1, math.sqrt(dx * dx + dy * dy))
            self.vx = (dx / dist) * speed
            self.vy = (dy / dist) * speed

            # Calculate rotation angle for drawing
            self.angle = math.degrees(math.atan2(dy, dx))
        except Exception as e:
            logging.error(f"Projectile.__init__ error: {str(e)}")
            raise

    def update(self) -> bool:
        """Returns True if projectile should be removed"""
        try:
            self.x += self.vx
            self.y += self.vy

            # Check if projectile is off-screen
            if (self.x < 0 or self.x > BATTLE_WIDTH or
                    self.y < 0 or self.y > BATTLE_HEIGHT):
                return True

            return False
        except Exception as e:
            logging.error(f"Projectile.update error: {str(e)}")
            return True

    def draw(self, screen: pygame.Surface, camera_x: int, camera_y: int):
        try:
            if self.is_missile:
                # Draw missile with special appearance
                missile_length = 15
                missile_width = 5
                points = [
                    (int(self.x - camera_x), int(self.y - camera_y)),
                    (int(self.x - camera_x - missile_length * math.cos(math.radians(self.angle))),
                     int(self.y - camera_y - missile_length * math.sin(math.radians(self.angle)))),
                    (int(self.x - camera_x - missile_length * math.cos(math.radians(self.angle)) +
                         missile_width * math.cos(math.radians(self.angle + 90))),
                     int(self.y - camera_y - missile_length * math.sin(math.radians(self.angle)) +
                         missile_width * math.sin(math.radians(self.angle + 90)))),
                    (int(self.x - camera_x - missile_length * math.cos(math.radians(self.angle)) +
                         missile_width * math.cos(math.radians(self.angle - 90))),
                     int(self.y - camera_y - missile_length * math.sin(math.radians(self.angle)) +
                         missile_width * math.sin(math.radians(self.angle - 90))))
                ]
                pygame.draw.polygon(screen, ORANGE, points)
                # Draw missile trail
                trail_length = 20
                pygame.draw.line(screen, YELLOW,
                                 (int(self.x - camera_x), int(self.y - camera_y)),
                                 (int(self.x - camera_x - trail_length * math.cos(math.radians(self.angle))),
                                  int(self.y - camera_y - trail_length * math.sin(math.radians(self.angle)))),
                                 2)
            elif not self.is_anti_fighter:
                pygame.draw.line(screen, self.color,
                                 (int(self.x - camera_x), int(self.y - camera_y)),
                                 (int(self.x - camera_x - self.vx), int(self.y - camera_y - self.vy)),
                                 self.size)
            else:
                # Draw anti-fighter weapon as a thinner, faster bolt
                pygame.draw.line(screen, (0, 255, 255),
                                 (int(self.x - camera_x), int(self.y - camera_y)),
                                 (int(self.x - camera_x - self.vx * 2), int(self.y - camera_y - self.vy * 2)),
                                 max(1, self.size // 2))
        except Exception as e:
            logging.error(f"Projectile.draw error: {str(e)}")


class Unit:
    def __init__(self, x: float, y: float, unit_type: UnitType, owner: int):
        try:
            self.x = x
            self.y = y
            self.type = unit_type
            self.owner = owner  # 0=player, 1=AI
            self.selected = False
            self.target_x = x
            self.target_y = y
            self.target_unit = None  # Specific unit to attack
            self.health = 1500 if unit_type == UnitType.SPACE_STATION else (
                2000 if unit_type == UnitType.RESEARCH_STATION else (
                    1200 if unit_type == UnitType.TRADE_STATION else (
                        500 if unit_type == UnitType.CAPITAL_SHIP else (
                            250 if unit_type == UnitType.CRUISER else (
                                150 if unit_type == UnitType.BOMBER else 100)))))
            self.max_health = self.health
            self.attack_cooldown = 0
            self.attack_timer = 0
            self.anti_fighter_cooldown = 0
            self.missile_cooldown = 0  # For bomber missiles
            self.last_detected_enemies = []  # Track last known enemy positions

            # Set stats based on type
            template = UNIT_TEMPLATES[unit_type]
            self.speed = 0 if template.is_station else (
                3 if unit_type == UnitType.FIGHTER else 2 if unit_type == UnitType.CRUISER else 1)
            self.attack_range = 300 if template.is_station else (200 if unit_type == UnitType.CAPITAL_SHIP else 150)
            self.attack_damage = template.strength * 2.5  # Was *25, now *2.5 (10x nerf)
            self.anti_fighter_damage = 0.5  # Low damage but rapid fire
            self.attack_rate = 60  # frames between attacks
            self.anti_fighter_rate = 15  # Faster firing for anti-fighter weapons
            self.missile_rate = 180  # Frames between missile attacks (3 seconds at 60 FPS)
            self.radius = 30 if template.is_station else (
                8 if unit_type == UnitType.FIGHTER else 12 if unit_type == UnitType.BOMBER else 15 if unit_type == UnitType.CRUISER else 25)
            self.color = BLUE if owner == 0 else IMPERIAL_GRAY
            self.projectile_color = template.projectile_color
            self.projectile_speed = template.projectile_speed
            self.projectile_size = template.projectile_size
            self.is_station = template.is_station
            self.is_research_station = template.is_research_station
            self.is_trade_station = template.is_trade_station
            self.vision_range = 250  # Range at which unit can see enemies
            self.detection_range = self.attack_range * 3  # Detection range is now 3x attack range

            # Generate unit image
            self.image = self._generate_unit_image()
            self.base_image = self.image.copy()

            logging.debug(f"Created {template.name} at ({x}, {y})")
        except Exception as e:
            logging.error(f"Unit.__init__ error: {str(e)}")
            raise

    def _generate_unit_image(self):
        """Generate unit image with error handling"""
        try:
            size = self.radius * 2
            surf = pygame.Surface((size * 2, size * 2), pygame.SRCALPHA)

            # Different shapes for each unit type
            if self.type == UnitType.FIGHTER:  # TIE Fighter
                # Solar panels
                pygame.draw.rect(surf, self.color, (size * 0.2, size * 0.4, size * 1.6, size * 0.2))
                # Cockpit
                pygame.draw.circle(surf, self.color, (size, size), size * 0.3)
                # Connecting arms
                pygame.draw.rect(surf, self.color, (size * 0.45, size * 0.3, size * 0.1, size * 0.4))
                pygame.draw.rect(surf, self.color, (size * 0.45, size * 0.3, size * 0.1, size * 0.4))

            elif self.type == UnitType.BOMBER:  # TIE Bomber (smaller than before)
                # Solar panels (smaller)
                pygame.draw.ellipse(surf, self.color, (size * 0.3, size * 0.4, size * 1.4, size * 0.3))
                # Cockpit
                pygame.draw.circle(surf, self.color, (size, size), size * 0.3)
                # Bomb bay
                pygame.draw.rect(surf, BLACK, (size * 0.4, size * 0.7, size * 0.2, size * 0.2))

            elif self.type == UnitType.CRUISER:  # Victory Cruiser (triangle)
                # Triangle hull
                points = [
                    (size, size * 0.2),  # Top
                    (size * 0.2, size * 1.8),  # Bottom left
                    (size * 1.8, size * 1.8)  # Bottom right
                ]
                pygame.draw.polygon(surf, self.color, points)
                # Bridge
                pygame.draw.rect(surf, self.color, (size * 0.8, size * 0.1, size * 0.4, size * 0.1))

            elif self.type == UnitType.CAPITAL_SHIP:  # Star Destroyer (large triangle)
                # Main hull - larger triangle to accommodate full design
                points = [
                    (size, 0),  # Tip
                    (size * 2.5, size * 4),  # Bottom right (extended)
                    (size * -0.5, size * 4)  # Bottom left (extended)
                ]
                pygame.draw.polygon(surf, GRAY, points)

                # Inner triangle for layered effect
                inner_points = [
                    (size, size * 0.2),  # Slightly below tip
                    (size * 2.2, size * 3.8),  # Bottom right (extended)
                    (size * -0.2, size * 3.8)  # Bottom left (extended)
                ]
                pygame.draw.polygon(surf, DARK_GRAY, inner_points)

                # Superstructure (bridge and central spine)
                pygame.draw.rect(surf, BRIDGE_GRAY,
                                 (size * 0.6, size * 3.5, size * 0.8, size * 0.3))

                # Shield spheres (now properly positioned)
                pygame.draw.circle(surf, LIGHT_GRAY,
                                   (int(size * 0.75), int(size * 3.6)), 8)  # Left sphere
                pygame.draw.circle(surf, LIGHT_GRAY,
                                   (int(size * 1.25), int(size * 3.6)), 8)  # Right sphere

                # Engines (now properly sized and positioned)
                # Left engine bank
                pygame.draw.rect(surf, GRAY,
                                 (size * 0.6, size * 3.8, size * 0.2, size * 0.15))
                pygame.draw.rect(surf, BLUE,
                                 (size * 0.6, size * 3.95, size * 0.2, size * 0.15))

                # Right engine bank
                pygame.draw.rect(surf, GRAY,
                                 (size * 1.2, size * 3.8, size * 0.2, size * 0.15))
                pygame.draw.rect(surf, BLUE,
                                 (size * 1.2, size * 3.95, size * 0.2, size * 0.15))

                # Center engine
                pygame.draw.rect(surf, GRAY,
                                 (size * 0.9, size * 3.8, size * 0.2, size * 0.15))
                pygame.draw.rect(surf, BLUE,
                                 (size * 0.9, size * 3.95, size * 0.2, size * 0.15))

                # Add some hull details
                for i in range(5):
                    # Port side details
                    pygame.draw.line(surf, LIGHT_GRAY,
                                     (size * 0.3, size * (1.0 + i * 0.5)),
                                     (size * 0.6, size * (1.0 + i * 0.5)), 2)
                    # Starboard side details
                    pygame.draw.line(surf, LIGHT_GRAY,
                                     (size * 1.4, size * (1.0 + i * 0.5)),
                                     (size * 1.7, size * (1.0 + i * 0.5)), 2)

            elif self.type == UnitType.SPACE_STATION:  # Space Station
                # Main ring
                pygame.draw.circle(surf, (*self.color, 150), (size, size), size)
                pygame.draw.circle(surf, BLACK, (size, size), size * 0.7)
                # Central sphere
                pygame.draw.circle(surf, self.color, (size, size), size * 0.5)
                # Turrets
                for i in range(8):
                    angle = math.radians(i * 45)
                    turret_x = size + math.cos(angle) * size * 0.8
                    turret_y = size + math.sin(angle) * size * 0.8
                    pygame.draw.circle(surf, self.color, (int(turret_x), int(turret_y)), size * 0.2)

            elif self.type == UnitType.RESEARCH_STATION:  # Research Station
                # Main structure
                pygame.draw.circle(surf, (*self.color, 150), (size, size), size)
                pygame.draw.circle(surf, BLACK, (size, size), size * 0.7)
                # Central sphere with special design
                pygame.draw.circle(surf, (0, 200, 255), (size, size), size * 0.5)
                # Science rings
                pygame.draw.circle(surf, (0, 150, 255), (size, size), size * 0.6, 2)
                pygame.draw.circle(surf, (0, 150, 255), (size, size), size * 0.4, 2)
                # Antenna
                pygame.draw.line(surf, (0, 200, 255), (size, size * 0.3), (size, size * 0.1), 3)

            elif self.type == UnitType.TRADE_STATION:  # New Trade Station
                # Main structure
                pygame.draw.circle(surf, (*self.color, 150), (size, size), size)
                pygame.draw.circle(surf, BLACK, (size, size), size * 0.7)
                # Central sphere with special design
                pygame.draw.circle(surf, (0, 255, 0), (size, size), size * 0.5)
                # Trade rings
                pygame.draw.circle(surf, (0, 200, 0), (size, size), size * 0.8, 3)
                pygame.draw.circle(surf, (0, 200, 0), (size, size), size * 0.5, 3)
                # Docking ports
                for i in range(6):
                    angle = math.radians(i * 60)
                    port_x = size + math.cos(angle) * size * 0.6
                    port_y = size + math.sin(angle) * size * 0.6
                    pygame.draw.rect(surf, (0, 150, 0), (port_x - 5, port_y - 10, 10, 20))

            return surf
        except Exception as e:
            logging.error(f"Unit._generate_unit_image error: {str(e)}")
            # Return a fallback surface
            fallback = pygame.Surface((50, 50), pygame.SRCALPHA)
            pygame.draw.circle(fallback, RED, (25, 25), 25)
            return fallback

    def update(self, units: List['Unit'], projectiles: List[Projectile]):
        """Update unit state with error handling"""
        try:
            # Trade stations don't attack
            if self.is_trade_station:
                return

            # Stations don't move
            if not self.is_station:
                # Movement - prioritize attacking target unit if one exists
                if self.target_unit and self.target_unit in units:
                    # Calculate optimal combat range (80-90% of max range)
                    optimal_min_range = self.attack_range * 0.8
                    optimal_max_range = self.attack_range * 0.9

                    # Calculate distance to target
                    dx = self.target_unit.x - self.x
                    dy = self.target_unit.y - self.y
                    distance = math.sqrt(dx * dx + dy * dy)

                    # Calculate direction vector
                    if distance > 0:
                        dir_x = dx / distance
                        dir_y = dy / distance
                    else:
                        dir_x, dir_y = 0, 0

                    # Maintain optimal combat range
                    if distance > optimal_max_range:
                        # Move toward target but stop at optimal range
                        self.target_x = self.target_unit.x - dir_x * optimal_min_range
                        self.target_y = self.target_unit.y - dir_y * optimal_min_range
                    elif distance < optimal_min_range:
                        # Move away to optimal range
                        self.target_x = self.x - dir_x * (optimal_min_range - distance)
                        self.target_y = self.y - dir_y * (optimal_min_range - distance)
                    else:
                        # Stay in place
                        self.target_x = self.x
                        self.target_y = self.y

                # Movement
                dx = self.target_x - self.x
                dy = self.target_y - self.y
                distance = math.sqrt(dx * dx + dy * dy)

                if distance > 5 and self.speed > 0:
                    self.x += (dx / distance) * self.speed
                    self.y += (dy / distance) * self.speed

            # Combat
            if self.attack_cooldown > 0:
                self.attack_cooldown -= 1
            else:
                self.attack(units, projectiles)

            # Anti-fighter weapons
            if self.anti_fighter_cooldown > 0:
                self.anti_fighter_cooldown -= 1
            elif self.type in (UnitType.CRUISER, UnitType.CAPITAL_SHIP):
                self.anti_fighter_attack(units, projectiles)

            # Bomber missiles
            if self.missile_cooldown > 0:
                self.missile_cooldown -= 1
            elif self.type == UnitType.BOMBER:
                self.missile_attack(units, projectiles)

            # Update last detected enemies list
            if self.owner == 1:  # AI units
                self.last_detected_enemies = [u for u in units if u.owner == 0 and
                                              math.sqrt(
                                                  (u.x - self.x) ** 2 + (u.y - self.y) ** 2) < self.detection_range]

            # Avoid collisions with other units
            self.avoid_collisions(units)
        except Exception as e:
            logging.error(f"Unit.update error: {str(e)}")

    def attack(self, units: List['Unit'], projectiles: List[Projectile]):
        """Handle unit attacks with error checking"""
        try:
            # If we have a specific target, prioritize it
            if self.target_unit and self.target_unit in units:
                target = self.target_unit
                dist = math.sqrt((target.x - self.x) ** 2 + (target.y - self.y) ** 2)
                if dist < self.attack_range:
                    # Create projectile
                    projectiles.append(Projectile(
                        self.x, self.y,
                        target.x, target.y,
                        self.attack_damage,
                        self.projectile_speed,
                        self.projectile_size,
                        self.projectile_color,
                        self.owner
                    ))
                    self.attack_cooldown = self.attack_rate
                    return

            # Otherwise find closest enemy
            closest_enemy = None
            closest_distance = float('inf')

            for unit in units:
                if unit.owner != self.owner:
                    dist = math.sqrt((unit.x - self.x) ** 2 + (unit.y - self.y) ** 2)
                    if dist < self.attack_range and dist < closest_distance:
                        closest_enemy = unit
                        closest_distance = dist

            if closest_enemy:
                # Create projectile
                projectiles.append(Projectile(
                    self.x, self.y,
                    closest_enemy.x, closest_enemy.y,
                    self.attack_damage,
                    self.projectile_speed,
                    self.projectile_size,
                    self.projectile_color,
                    self.owner
                ))
                self.attack_cooldown = self.attack_rate
        except Exception as e:
            logging.error(f"Unit.attack error: {str(e)}")

    def anti_fighter_attack(self, units: List['Unit'], projectiles: List[Projectile]):
        """Special attack that only targets fighters and bombers"""
        try:
            closest_fighter = None
            closest_distance = float('inf')

            for unit in units:
                if (unit.owner != self.owner and
                        unit.type in (UnitType.FIGHTER, UnitType.BOMBER)):
                    dist = math.sqrt((unit.x - self.x) ** 2 + (unit.y - self.y) ** 2)
                    if dist < self.attack_range and dist < closest_distance:
                        closest_fighter = unit
                        closest_distance = dist

            if closest_fighter:
                # Create anti-fighter projectile
                projectiles.append(Projectile(
                    self.x, self.y,
                    closest_fighter.x, closest_fighter.y,
                    self.anti_fighter_damage,
                    self.projectile_speed * 2,  # Faster projectiles
                    self.projectile_size // 2,  # Smaller projectiles
                    (0, 255, 255),  # Cyan color for anti-fighter weapons
                    self.owner,
                    True  # Mark as anti-fighter
                ))
                self.anti_fighter_cooldown = self.anti_fighter_rate
        except Exception as e:
            logging.error(f"Unit.anti_fighter_attack error: {str(e)}")

    def missile_attack(self, units: List['Unit'], projectiles: List[Projectile]):
        """Special attack for bombers that fires slow, powerful missiles"""
        try:
            target = None
            closest_distance = float('inf')

            for unit in units:
                if unit.owner != self.owner and unit.type in (UnitType.CRUISER, UnitType.CAPITAL_SHIP):
                    dist = math.sqrt((unit.x - self.x) ** 2 + (unit.y - self.y) ** 2)
                    if dist < self.attack_range and dist < closest_distance:
                        target = unit
                        closest_distance = dist

            if target:
                # Create missile - slower but more powerful
                damage_multiplier = 3.0  # Extra damage against capital ships and cruisers
                projectiles.append(Projectile(
                    self.x, self.y,
                    target.x, target.y,
                    self.attack_damage * damage_multiplier,  # Increased damage
                    self.projectile_speed * 0.5,  # Slower speed
                    self.projectile_size * 2,  # Larger size
                    ORANGE,  # Different color
                    self.owner,
                    False,  # Not anti-fighter
                    True  # Is missile
                ))
                self.missile_cooldown = self.missile_rate
        except Exception as e:
            logging.error(f"Unit.missile_attack error: {str(e)}")

    def avoid_collisions(self, units: List['Unit']):
        """Avoid collisions with other units with error handling"""
        try:
            if self.is_station:
                return

            for other in units:
                if other == self:
                    continue

                # Calculate distance between units
                dx = other.x - self.x
                dy = other.y - self.y
                dist = math.sqrt(dx * dx + dy * dy)
                min_dist = self.radius + other.radius + 10  # Minimum safe distance

                if dist < min_dist:
                    # Calculate repulsion vector
                    if dist == 0:  # Avoid division by zero
                        angle = random.uniform(0, 2 * math.pi)
                        repulse_x = math.cos(angle)
                        repulse_y = math.sin(angle)
                    else:
                        repulse_x = -dx / dist
                        repulse_y = -dy / dist

                    # Apply repulsion force (stronger when closer)
                    repulse_force = (min_dist - dist) * 0.5
                    self.x += repulse_x * repulse_force
                    self.y += repulse_y * repulse_force

                    # Clamp to battle area
                    self.x = max(self.radius, min(BATTLE_WIDTH - self.radius, self.x))
                    self.y = max(self.radius, min(BATTLE_HEIGHT - self.radius, self.y))
        except Exception as e:
            logging.error(f"Unit.avoid_collisions error: {str(e)}")

    def draw(self, screen: pygame.Surface, camera_x: int, camera_y: int):
        """Draw unit with error handling"""
        try:
            # Calculate rotation angle (stations don't rotate)
            screen_x = self.x - camera_x
            screen_y = self.y - camera_y

            if self.is_station:
                angle = 0
            else:
                angle = math.degrees(math.atan2(self.target_y - self.y, self.target_x - self.x)) + 90

            rotated_img = pygame.transform.rotate(self.base_image, -angle)

            # Draw the unit
            screen.blit(rotated_img, (int(screen_x) - rotated_img.get_width() // 2,
                                      int(screen_y) - rotated_img.get_height() // 2))

            # Selection circle
            if self.selected:
                pygame.draw.circle(screen, YELLOW, (int(screen_x), int(screen_y)), self.radius + 5, 2)

            # Health bar (not for trade stations)
            if not self.is_trade_station:
                bar_width = self.radius * 2
                health_percent = self.health / self.max_health
                pygame.draw.rect(screen, RED, (screen_x - self.radius, screen_y - self.radius - 10, bar_width, 5))
                pygame.draw.rect(screen, GREEN,
                                 (screen_x - self.radius, screen_y - self.radius - 10, bar_width * health_percent, 5))
        except Exception as e:
            logging.error(f"Unit.draw error: {str(e)}")
            # Draw error indicator
            pygame.draw.circle(screen, RED, (int(screen_x), int(screen_y)), 10)


# ========================
#       Planetary System
# ========================
class Planet:
    def __init__(self, x: float, y: float, name: str, production_rate: float = 1.0, resource_value: int = 10):
        try:
            self.x = x
            self.y = y
            self.name = name
            self.owner = -1  # -1=neutral, 0=player, 1=AI
            self.fleet: List[Unit] = []
            self.has_station = False
            self.has_research_station = False
            self.has_trade_station = False  # New trade station flag
            self.selected = False
            self.radius = 30
            self.production_rate = production_rate
            self.resource_value = resource_value
            self.production_queue: List[UnitType] = []
            self.current_production: Dict[str, float] = {}  # {"unit_type": progress}
            self.image = self._generate_planet_image()
            self.glow_surface = self._create_glow_surface()
            self.rotation_angle = random.uniform(0, 360)
            self.rotation_speed = random.uniform(0.1, 0.5)
            self.atmosphere_color = self._get_atmosphere_color()
            self.connected_planets: List[Planet] = []  # List of connected planets

            logging.debug(f"Created planet {name} at ({x}, {y})")
        except Exception as e:
            logging.error(f"Planet.__init__ error: {str(e)}")
            raise

    def _get_atmosphere_color(self):
        try:
            if self.owner == -1:
                return (100, 100, 100, 50)
            elif self.owner == 0:
                return (50, 50, 255, 80)
            else:
                return (255, 50, 50, 80)
        except Exception as e:
            logging.error(f"Planet._get_atmosphere_color error: {str(e)}")
            return (100, 100, 100, 50)

    def _create_glow_surface(self):
        try:
            size = self.radius * 4
            surf = pygame.Surface((size, size), pygame.SRCALPHA)

            # Create gradient glow
            for i in range(size // 2, 0, -1):
                alpha = int(100 * (i / (size / 2)))
                if self.owner == -1:
                    color = (150, 150, 150, alpha)
                elif self.owner == 0:
                    color = (100, 100, 255, alpha)
                else:
                    color = (255, 100, 100, alpha)
                pygame.draw.circle(surf, color, (size // 2, size // 2), i)

            return surf
        except Exception as e:
            logging.error(f"Planet._create_glow_surface error: {str(e)}")
            # Return empty surface as fallback
            return pygame.Surface((1, 1), pygame.SRCALPHA)

    def _generate_planet_image(self):
        try:
            size = self.radius * 2
            surf = pygame.Surface((size * 2, size * 2), pygame.SRCALPHA)

            # Base planet color based on name hash
            random.seed(hash(self.name))
            base_color = (
                random.randint(50, 200),
                random.randint(50, 200),
                random.randint(50, 200)
            )

            # Draw planet
            pygame.draw.circle(surf, base_color, (size, size), size)

            # Add surface details
            for _ in range(20):
                x = random.randint(0, size * 2)
                y = random.randint(0, size * 2)
                if math.sqrt((x - size) ** 2 + (y - size) ** 2) < size:
                    detail_color = (
                        min(255, base_color[0] + random.randint(-30, 30)),
                        min(255, base_color[1] + random.randint(-30, 30)),
                        min(255, base_color[2] + random.randint(-30, 30))
                    )
                    radius = random.randint(1, 5)
                    pygame.draw.circle(surf, detail_color, (x, y), radius)

            # Add atmosphere if owned
            if self.owner != -1:
                atmosphere = pygame.Surface((size * 2, size * 2), pygame.SRCALPHA)
                pygame.draw.circle(atmosphere, self.atmosphere_color[:3] + (50,), (size, size), size + 5)
                surf.blit(atmosphere, (0, 0), special_flags=pygame.BLEND_ADD)

            return surf
        except Exception as e:
            logging.error(f"Planet._generate_planet_image error: {str(e)}")
            # Return fallback image
            fallback = pygame.Surface((60, 60), pygame.SRCALPHA)
            pygame.draw.circle(fallback, (100, 100, 100), (30, 30), 30)
            return fallback

    def update_production(self, dt: float):
        """Update planet production with error handling"""
        try:
            if self.owner == -1:
                return  # Neutral planets don't produce ships

            # Update rotation
            self.rotation_angle += self.rotation_speed
            if self.rotation_angle >= 360:
                self.rotation_angle -= 360

            # Update current production (5x faster)
            for unit_type, progress in list(self.current_production.items()):
                self.current_production[unit_type] = progress + dt * self.production_rate * PRODUCTION_SPEED_MULTIPLIER
                template = UNIT_TEMPLATES[UnitType[unit_type]]

                if self.current_production[unit_type] >= template.build_time:
                    if template.is_station and not template.is_trade_station and not template.is_research_station:
                        # Only one space station per planet
                        if not self.has_station:
                            self.has_station = True
                            logging.info(f"{self.name} built a Space Station")
                    elif template.is_research_station:
                        if not self.has_research_station:
                            self.has_research_station = True
                            logging.info(f"{self.name} built a Research Station")
                    elif template.is_trade_station:
                        if not self.has_trade_station:
                            self.has_trade_station = True
                            self.resource_value *= 3  # Triple the planet's income
                            logging.info(f"{self.name} built a Trade Station")
                    else:
                        self.fleet.append(Unit(
                            self.x + random.uniform(-20, 20),
                            self.y + random.uniform(-20, 20),
                            UnitType[unit_type],
                            self.owner
                        ))
                        logging.debug(f"{self.name} produced a {template.name}")
                    del self.current_production[unit_type]

            # Start new production if queue not empty and production slots available
            if len(self.current_production) < 3 and self.production_queue:
                next_unit = self.production_queue.pop(0)
                self.current_production[next_unit.name] = 0.0
        except Exception as e:
            logging.error(f"Planet.update_production error: {str(e)}")

    def add_to_production_queue(self, unit_type: UnitType, player_resources: int) -> bool:
        """Add unit to production queue with error checking"""
        try:
            if self.owner != 0:  # Only player can manually queue units
                return False

            template = UNIT_TEMPLATES[unit_type]

            # Check if trying to build duplicate stations
            if ((
                    template.is_station and not template.is_research_station and not template.is_trade_station and self.has_station) or
                    (template.is_research_station and self.has_research_station) or
                    (template.is_trade_station and self.has_trade_station)):
                logging.warning(f"Cannot build duplicate station on {self.name}")
                return False

            # Check if planet has a space station (required for ship production)
            if not template.is_station and not self.has_station:
                logging.warning(f"{self.name} needs a Space Station to build ships")
                return False

            if template.cost <= player_resources:
                self.production_queue.append(unit_type)
                logging.info(f"Queued {template.name} on {self.name}")
                return True
            logging.warning(f"Not enough resources to build {template.name}")
            return False
        except Exception as e:
            logging.error(f"Planet.add_to_production_queue error: {str(e)}")
            return False

    def draw(self, screen: pygame.Surface):
        """Draw planet with error handling"""
        try:
            # Draw glow
            screen.blit(self.glow_surface, (self.x - self.glow_surface.get_width() // 2,
                                            self.y - self.glow_surface.get_height() // 2))

            # Draw planet (rotated)
            rotated_planet = pygame.transform.rotate(self.image, self.rotation_angle)
            screen.blit(rotated_planet, (self.x - rotated_planet.get_width() // 2,
                                         self.y - rotated_planet.get_height() // 2))

            if self.selected:
                # Draw selection circle with pulse effect
                pulse = math.sin(pygame.time.get_ticks() * 0.005) * 5 + 35
                pygame.draw.circle(screen, YELLOW, (int(self.x), int(self.y)), int(pulse), 2)

                # Draw connections to other planets
                for planet in self.connected_planets:
                    pygame.draw.line(screen, (*WHITE, 100), (self.x, self.y), (planet.x, planet.y), 2)

            # Draw fleet count
            if self.fleet:
                font = pygame.font.Font(None, 24)
                text = font.render(str(len(self.fleet)), True, WHITE)
                text_shadow = font.render(str(len(self.fleet)), True, BLACK)

                # Draw shadow first
                for offset in [(1, 1), (-1, -1), (1, -1), (-1, 1)]:
                    screen.blit(text_shadow, (self.x - 5 + offset[0], self.y - 45 + offset[1]))

                # Draw main text
                screen.blit(text, (self.x - 5, self.y - 45))

            # Draw station indicators
            if self.has_station:
                station_icon = pygame.Surface((20, 20), pygame.SRCALPHA)
                pygame.draw.circle(station_icon, YELLOW, (10, 10), 10)
                pygame.draw.circle(station_icon, BLACK, (10, 10), 6)
                screen.blit(station_icon, (self.x - 10, self.y - 60))

            if self.has_research_station:
                research_icon = pygame.Surface((20, 20), pygame.SRCALPHA)
                pygame.draw.circle(research_icon, (0, 200, 255), (10, 10), 10)
                pygame.draw.circle(research_icon, BLACK, (10, 10), 6)
                screen.blit(research_icon, (self.x + 10, self.y - 60))

            if self.has_trade_station:
                trade_icon = pygame.Surface((20, 20), pygame.SRCALPHA)
                pygame.draw.circle(trade_icon, (0, 255, 0), (10, 10), 10)
                pygame.draw.circle(trade_icon, BLACK, (10, 10), 6)
                screen.blit(trade_icon, (self.x + 30, self.y - 60))

            # Draw production info if selected and owned by player
            if self.selected and self.owner == 0:
                self.draw_production_info(screen)
        except Exception as e:
            logging.error(f"Planet.draw error: {str(e)}")

    def draw_production_info(self, screen: pygame.Surface):
        """Draw production panel with error handling"""
        try:
            # Draw production panel with glass effect
            panel_rect = pygame.Rect(50, SCREEN_HEIGHT - 200, 400, 150)

            # Create glass surface
            glass = pygame.Surface((panel_rect.width, panel_rect.height), pygame.SRCALPHA)
            pygame.draw.rect(glass, (*DARK_BLUE, 180), (0, 0, panel_rect.width, panel_rect.height), border_radius=10)
            pygame.draw.rect(glass, (255, 255, 255, 30), (0, 0, panel_rect.width, panel_rect.height), 2,
                             border_radius=10)

            # Add noise for glass effect
            for _ in range(100):
                x = random.randint(0, panel_rect.width)
                y = random.randint(0, panel_rect.height)
                glass.set_at((x, y), (255, 255, 255, random.randint(5, 20)))

            screen.blit(glass, panel_rect)

            font = pygame.font.Font(None, 24)
            title = font.render(f"{self.name} Production", True, WHITE)
            screen.blit(title, (panel_rect.x + 15, panel_rect.y + 15))

            # Current production
            y_offset = 40
            for unit_type, progress in self.current_production.items():
                template = UNIT_TEMPLATES[UnitType[unit_type]]
                progress_percent = min(100, int(progress / template.build_time * 100))

                # Progress bar background
                pygame.draw.rect(screen, (*BLACK, 150), (panel_rect.x + 15, panel_rect.y + y_offset + 15, 200, 10))

                # Progress bar fill
                pygame.draw.rect(screen, GREEN,
                                 (panel_rect.x + 15, panel_rect.y + y_offset + 15, 200 * progress_percent / 100, 10))

                text = font.render(f"{template.name}: {progress_percent}%", True, WHITE)
                screen.blit(text, (panel_rect.x + 15, panel_rect.y + y_offset))
                y_offset += 35

            # Queue
            if self.production_queue:
                queue_text = font.render("Queue:", True, WHITE)
                screen.blit(queue_text, (panel_rect.x + 15, panel_rect.y + y_offset))
                y_offset += 25

                for unit_type in self.production_queue[:3]:  # Only show first 3
                    template = UNIT_TEMPLATES[unit_type]
                    text = font.render(template.name, True, WHITE)
                    screen.blit(text, (panel_rect.x + 25, panel_rect.y + y_offset))
                    y_offset += 25
        except Exception as e:
            logging.error(f"Planet.draw_production_info error: {str(e)}")


# ========================
#       Fleet Movement
# ========================
class FleetMovement:
    def __init__(self, source: Planet, target: Planet, units: List[Unit], owner: int):
        try:
            self.source = source
            self.target = target
            self.units = units
            self.owner = owner
            self.progress = 0.0
            self.speed = 0.5
            self.x = source.x
            self.y = source.y
            self.trail_positions = []
            self.trail_max_length = 20

            logging.debug(f"Created fleet movement from {source.name} to {target.name} with {len(units)} units")
        except Exception as e:
            logging.error(f"FleetMovement.__init__ error: {str(e)}")
            raise

    def update(self) -> bool:
        """Update fleet movement with error handling"""
        try:
            self.progress += 0.001 * self.speed
            if self.progress >= 1.0:
                return True

            # Update position
            prev_x, prev_y = self.x, self.y
            self.x = self.source.x + (self.target.x - self.source.x) * self.progress
            self.y = self.source.y + (self.target.y - self.source.y) * self.progress

            # Add to trail
            self.trail_positions.append((self.x, self.y))
            if len(self.trail_positions) > self.trail_max_length:
                self.trail_positions.pop(0)

            return False
        except Exception as e:
            logging.error(f"FleetMovement.update error: {str(e)}")
            return True  # Remove if error occurs

    def draw(self, screen: pygame.Surface):
        """Draw fleet movement with error handling"""
        try:
            color = BLUE if self.owner == 0 else RED

            # Draw trail
            if len(self.trail_positions) > 1:
                points = [(int(x), int(y)) for x, y in self.trail_positions]
                pygame.draw.lines(screen, (*color, 100), False, points, 2)

            # Draw fleet indicator
            pygame.draw.circle(screen, color, (int(self.x), int(self.y)), 8)

            # Draw inner glow
            pygame.draw.circle(screen, (*color, 150), (int(self.x), int(self.y)), 5)

            # Draw fleet size indicator
            font = pygame.font.Font(None, 18)
            text = font.render(str(len(self.units)), True, WHITE)
            text_shadow = font.render(str(len(self.units)), True, BLACK)

            # Draw shadow first
            for offset in [(1, 1), (-1, -1), (1, -1), (-1, 1)]:
                screen.blit(text_shadow, (int(self.x) - 5 + offset[0], int(self.y) - 8 + offset[1]))

            # Draw main text
            screen.blit(text, (int(self.x) - 5, int(self.y) - 8))
        except Exception as e:
            logging.error(f"FleetMovement.draw error: {str(e)}")


# ========================
#       MiniMap
# ========================
class MiniMap:
    def __init__(self, width: int, height: int, battle_width: int, battle_height: int):
        try:
            self.width = width
            self.height = height
            self.battle_width = battle_width
            self.battle_height = battle_height
            self.surface = pygame.Surface((width, height), pygame.SRCALPHA)
            self.rect = pygame.Rect(SCREEN_WIDTH - width - 20, 20, width, height)
            self.border_color = (100, 100, 255, 150)
            self.bg_color = (0, 0, 50, 100)
            self.camera_color = (255, 255, 255, 100)
            self.unit_colors = {
                0: (0, 0, 255, 200),  # Player units (blue)
                1: (255, 0, 0, 200)  # Enemy units (red)
            }
        except Exception as e:
            logging.error(f"MiniMap.__init__ error: {str(e)}")
            raise

    def update(self, units: List[Unit], camera_x: int, camera_y: int):
        """Update the minimap with error handling"""
        try:
            self.surface.fill((0, 0, 0, 0))

            # Draw background
            pygame.draw.rect(self.surface, self.bg_color, (0, 0, self.width, self.height))
            pygame.draw.rect(self.surface, self.border_color, (0, 0, self.width, self.height), 2)

            # Calculate scale factors
            scale_x = self.width / self.battle_width
            scale_y = self.height / self.battle_height

            # Draw camera view rectangle
            cam_rect = pygame.Rect(
                camera_x * scale_x,
                camera_y * scale_y,
                SCREEN_WIDTH * scale_x,
                SCREEN_HEIGHT * scale_y
            )
            pygame.draw.rect(self.surface, self.camera_color, cam_rect, 1)

            # Draw all units (no fog of war)
            for unit in units:
                x = unit.x * scale_x
                y = unit.y * scale_y
                size = max(2, unit.radius * min(scale_x, scale_y))
                pygame.draw.circle(
                    self.surface,
                    self.unit_colors.get(unit.owner, (255, 255, 255, 200)),
                    (int(x), int(y)),
                    int(size)
                )
        except Exception as e:
            logging.error(f"MiniMap.update error: {str(e)}")

    def draw(self, screen: pygame.Surface):
        """Draw the minimap with error handling"""
        try:
            screen.blit(self.surface, self.rect)

            # Draw border
            pygame.draw.rect(screen, self.border_color, self.rect, 2)
        except Exception as e:
            logging.error(f"MiniMap.draw error: {str(e)}")


# ========================
#       Main Game Class
# ========================
class EmpireAtWarGame:
    def __init__(self):
        """Initialize game with error handling"""
        try:
            self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
            pygame.display.set_caption("Empire at War - Star Wars Edition")
            self.clock = pygame.time.Clock()
            self.running = True
            self.state = GameState.GALACTIC_MAP
            self.font = pygame.font.Font(None, 28)
            self.title_font = pygame.font.Font(None, 48)
            self.victory_font = pygame.font.Font(None, 72)
            self.button_font = pygame.font.Font(None, 24)

            # Game objects
            self.planets: List[Planet] = []
            self.fleets_in_transit: List[FleetMovement] = []
            self.selected_planet: Planet = None
            self.battle_units: List[Unit] = []
            self.battle_projectiles: List[Projectile] = []
            self.current_battle_planet: Planet = None
            self.enemy_spawn_point = (0, 0)

            # Camera for tactical battles
            self.camera_x = 0
            self.camera_y = 0
            self.camera_speed = 15
            self.camera_follow = False

            # Resources and time
            self.player_resources = 10000
            self.ai_resources = 10000
            self.galactic_day_timer = 0.0
            self.current_day = 1
            self.last_time = pygame.time.get_ticks()

            # Tech tree
            self.tech_tree = TechTree()
            self.ai_tech_tree = TechTree()

            # AI tracking
            self.ai_tie_fighter_count = 0  # Track how many TIE fighters AI has produced

            # Visual effects
            self.starfield = self._generate_starfield()
            self.background_gradient = self._create_background_gradient()

            # MiniMap
            self.minimap = MiniMap(200, 200, BATTLE_WIDTH, BATTLE_HEIGHT)

            # UI Elements
            self.production_buttons = []
            self.selection_start = None
            self.selection_rect = None

            # Debug tracking
            self.frame_count = 0
            self.debug_messages = []

            # Initialize galaxy
            self._generate_galaxy()

            # Starting forces
            self.planets[0].owner = 0
            self.planets[0].has_station = True
            self.planets[-1].owner = 1
            self.planets[-1].has_station = True

            logging.info("Game initialized successfully")
        except Exception as e:
            logging.critical(f"Game initialization failed: {str(e)}")
            traceback.print_exc()
            self.running = False

    def _generate_starfield(self):
        """Generate starfield background with error handling"""
        try:
            starfield = pygame.Surface((BATTLE_WIDTH, BATTLE_HEIGHT))
            starfield.fill(SPACE_COLOR)

            # Draw distant stars
            for _ in range(2000):
                x = random.randint(0, BATTLE_WIDTH)
                y = random.randint(0, BATTLE_HEIGHT)
                brightness = random.randint(50, 150)
                size = random.randint(1, 2)
                pygame.draw.circle(starfield, (brightness, brightness, brightness), (x, y), size)

            return starfield
        except Exception as e:
            logging.error(f"_generate_starfield error: {str(e)}")
            # Return fallback surface
            fallback = pygame.Surface((BATTLE_WIDTH, BATTLE_HEIGHT))
            fallback.fill(SPACE_COLOR)
            return fallback

    def _create_background_gradient(self):
        """Create background gradient with error handling"""
        try:
            gradient = pygame.Surface((BATTLE_WIDTH, BATTLE_HEIGHT))

            # Create vertical gradient
            for y in range(BATTLE_HEIGHT):
                r = int(5 + 10 * math.sin(y / 100))
                g = int(5 + 10 * math.sin(y / 120 + 1))
                b = int(25 + 10 * math.sin(y / 80 + 2))
                pygame.draw.line(gradient, (20, 20, 20), (0, y), (BATTLE_WIDTH, y))

            # Add some nebula-like patches
            for _ in range(10):
                center_x = random.randint(0, BATTLE_WIDTH)
                center_y = random.randint(0, BATTLE_HEIGHT)
                radius = random.randint(200, 500)
                color = (
                    random.randint(10, 30),
                    random.randint(10, 20),
                    random.randint(30, 50))

                for r in range(radius, 0, -20):
                    alpha = int(30 * (r / radius))
                    temp_surf = pygame.Surface((r * 2, r * 2), pygame.SRCALPHA)
                    pygame.draw.circle(temp_surf, (*color, alpha), (r, r), r)
                    gradient.blit(temp_surf, (center_x - r, center_y - r))

            return gradient
        except Exception as e:
            logging.error(f"_create_background_gradient error: {str(e)}")
            # Return fallback surface
            fallback = pygame.Surface((BATTLE_WIDTH, BATTLE_HEIGHT))
            fallback.fill((10, 10, 30))
            return fallback

    def _generate_galaxy(self):
        """Generate galaxy with error handling"""
        try:
            planet_data = [
                ("Coruscant", 1.5, 20),
                ("Tatooine", 0.8, 5),
                ("Naboo", 1.2, 15),
                ("Hoth", 0.7, 8),
                ("Kamino", 1.3, 12)
            ]

            for i, (name, prod_rate, res_value) in enumerate(planet_data):
                x = 200 + i * 250
                y = 360 if i % 2 == 0 else 300
                planet = Planet(x, y, name, prod_rate, res_value)

                # Add some starting ships
                if i == 0:  # Player homeworld
                    planet.fleet = [Unit(planet.x + random.uniform(-20, 20),
                                         planet.y + random.uniform(-20, 20),
                                         UnitType.FIGHTER, 0) for _ in range(3)]
                elif i == len(planet_data) - 1:  # AI homeworld
                    planet.fleet = [Unit(planet.x + random.uniform(-20, 20),
                                         planet.y + random.uniform(-20, 20),
                                         UnitType.FIGHTER, 1) for _ in range(3)]

                self.planets.append(planet)

            # Set up planet connections
            for i, planet in enumerate(self.planets):
                if i > 0:
                    planet.connected_planets.append(self.planets[i - 1])
                if i < len(self.planets) - 1:
                    planet.connected_planets.append(self.planets[i + 1])

            logging.info("Galaxy generated with %d planets", len(self.planets))
        except Exception as e:
            logging.error(f"_generate_galaxy error: {str(e)}")
            traceback.print_exc()
            self.planets = []  # Reset planets if generation fails

    def _start_battle(self, attacking_fleet: List[Unit], planet: Planet):
        """Start battle with error handling"""
        try:
            if not attacking_fleet or not planet:
                logging.error("Invalid battle parameters")
                return

            logging.info(f"Starting battle at {planet.name}")
            self.state = GameState.TACTICAL_BATTLE
            self.current_battle_planet = planet
            self.battle_units = []
            self.battle_projectiles = []

            # Set up spawn points
            self.enemy_spawn_point = (BATTLE_WIDTH * 0.1, BATTLE_HEIGHT * 0.9)

            # Defenders spawn near middle
            defender_spawn_x = planet.x
            defender_spawn_y = planet.y

            # Center camera on planet
            self.camera_x = planet.x - SCREEN_WIDTH // 2
            self.camera_y = planet.y - SCREEN_HEIGHT // 2
            self.camera_follow = False

            # Add attacking fleet
            for i, unit in enumerate(attacking_fleet):
                new_unit = Unit(
                    self.enemy_spawn_point[0] + random.uniform(-100, 100),
                    self.enemy_spawn_point[1] + random.uniform(-100, 100),
                    unit.type,
                    unit.owner
                )
                new_unit.target_x = planet.x
                new_unit.target_y = planet.y
                self.battle_units.append(new_unit)

            # Add defending fleet
            for unit in planet.fleet:
                self.battle_units.append(Unit(
                    defender_spawn_x + random.uniform(-100, 100),
                    defender_spawn_y + random.uniform(-100, 100),
                    unit.type,
                    unit.owner
                ))

            # Add space station if it exists
            if planet.has_station:
                station = Unit(
                    planet.x,
                    planet.y,
                    UnitType.SPACE_STATION,
                    planet.owner
                )
                self.battle_units.append(station)

            # Add research station if it exists
            if planet.has_research_station:
                research_station = Unit(
                    planet.x,
                    planet.y,
                    UnitType.RESEARCH_STATION,
                    planet.owner
                )
                self.battle_units.append(research_station)

            # Add trade station if it exists (but only one per battle)
            if planet.has_trade_station:
                trade_station = Unit(
                    planet.x,
                    planet.y,
                    UnitType.TRADE_STATION,
                    planet.owner
                )
                self.battle_units.append(trade_station)

            logging.info(f"Battle started with {len(self.battle_units)} units")
        except Exception as e:
            logging.error(f"_start_battle error: {str(e)}")
            traceback.print_exc()
            self.state = GameState.GALACTIC_MAP  # Revert to galactic map if battle fails

    def _update_camera(self):
        """Update camera with error handling"""
        try:
            keys = pygame.key.get_pressed()

            # Toggle camera follow mode
            if keys[pygame.K_f]:
                self.camera_follow = not self.camera_follow
                logging.debug(f"Camera follow: {self.camera_follow}")

            # Handle keyboard camera movement
            if keys[pygame.K_LEFT]:
                self.camera_x = max(0, self.camera_x - self.camera_speed)
                self.camera_follow = False
            if keys[pygame.K_RIGHT]:
                self.camera_x = min(BATTLE_WIDTH - SCREEN_WIDTH, self.camera_x + self.camera_speed)
                self.camera_follow = False
            if keys[pygame.K_UP]:
                self.camera_y = max(0, self.camera_y - self.camera_speed)
                self.camera_follow = False
            if keys[pygame.K_DOWN]:
                self.camera_y = min(BATTLE_HEIGHT - SCREEN_HEIGHT, self.camera_y + self.camera_speed)
                self.camera_follow = False

            # Follow player units if in follow mode
            if self.camera_follow and self.battle_units:
                player_units = [u for u in self.battle_units if u.owner == 0]
                if player_units:
                    avg_x = sum(u.x for u in player_units) / len(player_units)
                    avg_y = sum(u.y for u in player_units) / len(player_units)

                    # Smooth camera movement toward player units
                    target_x = avg_x - SCREEN_WIDTH // 2
                    target_y = avg_y - SCREEN_HEIGHT // 2

                    # Clamp targets to battle area
                    target_x = max(0, min(BATTLE_WIDTH - SCREEN_WIDTH, target_x))
                    target_y = max(0, min(BATTLE_HEIGHT - SCREEN_HEIGHT, target_y))

                    # Move camera toward target
                    self.camera_x += (target_x - self.camera_x) * 0.1
                    self.camera_y += (target_y - self.camera_y) * 0.1

                    # Debug logging
                    if DEBUG_MODE and self.frame_count % 60 == 0:
                        self.debug_messages.append(
                            f"Camera: ({self.camera_x:.1f}, {self.camera_y:.1f}) "
                            f"Target: ({target_x:.1f}, {target_y:.1f})"
                        )
        except Exception as e:
            logging.error(f"_update_camera error: {str(e)}")

    def _end_battle(self, victor: int):
        """End battle with error handling"""
        try:
            logging.info(f"Battle ended, victor: {'Player' if victor == 0 else 'AI'}")
            self.state = GameState.GALACTIC_MAP

            # Update planet ownership
            self.current_battle_planet.owner = victor
            logging.info(f"{self.current_battle_planet.name} captured by {'Player' if victor == 0 else 'AI'}")

            # Add surviving units to planet
            self.current_battle_planet.fleet = [
                Unit(
                    self.current_battle_planet.x + random.uniform(-20, 20),
                    self.current_battle_planet.y + random.uniform(-20, 20),
                    unit.type,
                    victor
                )
                for unit in self.battle_units
                if unit.owner == victor and unit.health > 0 and not unit.is_station
                   and not unit.is_research_station and not unit.is_trade_station
            ]
            logging.info(f"{len(self.current_battle_planet.fleet)} units survived")

            # Handle space station (if it survived)
            station_survived = any(unit for unit in self.battle_units
                                   if unit.is_station and not unit.is_research_station
                                   and not unit.is_trade_station and unit.owner == victor and unit.health > 0)
            self.current_battle_planet.has_station = station_survived
            if station_survived:
                logging.info("Space station survived")

            # Handle research station (if it survived)
            research_station_survived = any(unit for unit in self.battle_units
                                            if unit.is_research_station and unit.owner == victor and unit.health > 0)
            self.current_battle_planet.has_research_station = research_station_survived
            if research_station_survived:
                logging.info("Research station survived")

            # Handle trade station (if it survived)
            trade_station_survived = any(unit for unit in self.battle_units
                                         if unit.is_trade_station and unit.owner == victor and unit.health > 0)
            self.current_battle_planet.has_trade_station = trade_station_survived
            if not trade_station_survived:
                # Reset income if trade station was destroyed
                self.current_battle_planet.resource_value = max(10, self.current_battle_planet.resource_value // 3)
                logging.info("Trade station destroyed")
            else:
                logging.info("Trade station survived")

            self.battle_units = []
            self.battle_projectiles = []
            self.current_battle_planet = None

            # Check win/lose conditions
            self._check_victory_conditions()
        except Exception as e:
            logging.error(f"_end_battle error: {str(e)}")
            traceback.print_exc()
            # Attempt to recover by resetting to galactic map
            self.state = GameState.GALACTIC_MAP
            self.battle_units = []
            self.battle_projectiles = []
            self.current_battle_planet = None

    def _check_victory_conditions(self):
        """Check victory conditions with error handling"""
        try:
            player_planets = sum(1 for p in self.planets if p.owner == 0)
            ai_planets = sum(1 for p in self.planets if p.owner == 1)

            if player_planets == len(self.planets):
                self.state = GameState.VICTORY
                logging.info("Player achieved victory!")
            elif ai_planets == len(self.planets):
                self.state = GameState.DEFEAT
                logging.info("AI achieved victory!")
        except Exception as e:
            logging.error(f"_check_victory_conditions error: {str(e)}")

    def _update_ai_units(self):
        """Update AI units with error handling"""
        try:
            ai_units = [u for u in self.battle_units if u.owner == 1]

            for ai_unit in ai_units:
                # Find closest player unit
                closest_player = None
                min_distance = float('inf')

                for player_unit in [u for u in self.battle_units if u.owner == 0]:
                    dist = math.sqrt((player_unit.x - ai_unit.x) ** 2 + (player_unit.y - ai_unit.y) ** 2)

                    if dist < ai_unit.detection_range and dist < min_distance:
                        min_distance = dist
                        closest_player = player_unit

                if closest_player:
                    # Set target unit
                    ai_unit.target_unit = closest_player

                    # Calculate optimal combat range (80-90% of max range)
                    optimal_min_range = ai_unit.attack_range * 0.8
                    optimal_max_range = ai_unit.attack_range * 0.9

                    # Calculate direction vector
                    dx = closest_player.x - ai_unit.x
                    dy = closest_player.y - ai_unit.y
                    distance = math.sqrt(dx * dx + dy * dy)

                    if distance > 0:
                        dir_x = dx / distance
                        dir_y = dy / distance
                    else:
                        dir_x, dir_y = 0, 0

                    # Maintain optimal combat range
                    if distance > optimal_max_range:
                        # Move toward target but stop at optimal range
                        ai_unit.target_x = closest_player.x - dir_x * optimal_min_range
                        ai_unit.target_y = closest_player.y - dir_y * optimal_min_range
                    elif distance < optimal_min_range:
                        # Move away to optimal range
                        ai_unit.target_x = ai_unit.x - dir_x * (optimal_min_range - distance)
                        ai_unit.target_y = ai_unit.y - dir_y * (optimal_min_range - distance)
                    else:
                        # Stay in place
                        ai_unit.target_x = ai_unit.x
                        ai_unit.target_y = ai_unit.y
                else:
                    # No visible enemies, move toward last known position
                    if ai_unit.last_detected_enemies:
                        ai_unit.target_x = ai_unit.last_detected_enemies[0].x
                        ai_unit.target_y = ai_unit.last_detected_enemies[0].y
        except Exception as e:
            logging.error(f"_update_ai_units error: {str(e)}")

    def _update_projectiles(self):
        """Update projectiles with error handling"""
        try:
            for proj in self.battle_projectiles[:]:
                if proj.update():  # Remove if off-screen
                    self.battle_projectiles.remove(proj)
                    continue

                # Check for hits against other projectiles (for missile interception)
                if proj.is_missile:
                    for other_proj in self.battle_projectiles[:]:
                        if other_proj.owner != proj.owner and not other_proj.is_missile:
                            dist = math.sqrt((other_proj.x - proj.x) ** 2 + (other_proj.y - proj.y) ** 2)
                            if dist < proj.size + other_proj.size:
                                proj.health -= 1
                                if other_proj in self.battle_projectiles:
                                    self.battle_projectiles.remove(other_proj)
                                if proj.health <= 0 and proj in self.battle_projectiles:
                                    self.battle_projectiles.remove(proj)
                                break

                # Check for hits against units (now includes trade stations)
                for unit in self.battle_units[:]:
                    if unit.owner != proj.owner:  # Removed trade station exclusion
                        # Anti-fighter weapons only damage fighters and bombers
                        if proj.is_anti_fighter and unit.type not in (UnitType.FIGHTER, UnitType.BOMBER):
                            continue

                        dist = math.sqrt((unit.x - proj.x) ** 2 + (unit.y - proj.y) ** 2)
                        if dist < unit.radius + proj.size:
                            # Extra damage from missiles to capital ships and cruisers
                            damage = proj.damage
                            if proj.is_missile and unit.type in (UnitType.CRUISER, UnitType.CAPITAL_SHIP):
                                damage *= 2  # Double damage to capital ships

                            unit.health -= damage
                            if proj in self.battle_projectiles:
                                self.battle_projectiles.remove(proj)
                            break
        except Exception as e:
            logging.error(f"_update_projectiles error: {str(e)}")

    def _collect_galactic_resources(self):
        """Collect resources with error handling"""
        try:
            # Player resources
            player_planets = [p for p in self.planets if p.owner == 0]
            self.player_resources += sum(p.resource_value for p in player_planets)
            logging.debug(f"Player resources: {self.player_resources}")

            # AI resources
            ai_planets = [p for p in self.planets if p.owner == 1]
            self.ai_resources += sum(p.resource_value for p in ai_planets)
            logging.debug(f"AI resources: {self.ai_resources}")

            self.current_day += 1
            logging.info(f"New galactic day: {self.current_day}")

            # Update research
            self.tech_tree.update_research(1.0)
            self.ai_tech_tree.update_research(1.0)

            # Check victory conditions at the start of each new day
            self._check_victory_conditions()
        except Exception as e:
            logging.error(f"_collect_galactic_resources error: {str(e)}")

    def _create_production_buttons(self):
        """Create production buttons with error handling"""
        try:
            self.production_buttons = []
            if not self.selected_planet or self.selected_planet.owner != 0:
                return

            button_width = 180
            button_height = 40
            start_x = 50
            start_y = SCREEN_HEIGHT - 250  # Moved up slightly
            button_spacing = 15

            # Organize buttons in 2 columns with proper spacing
            for i, unit_type in enumerate(UNIT_TEMPLATES.keys()):
                template = UNIT_TEMPLATES[unit_type]

                if not self.tech_tree.can_build(unit_type):
                    continue

                # Skip if trying to build duplicate stations
                if ((
                        template.is_station and not template.is_research_station and not template.is_trade_station and self.selected_planet.has_station) or
                        (template.is_research_station and self.selected_planet.has_research_station) or
                        (template.is_trade_station and self.selected_planet.has_trade_station)):
                    continue

                # Check if planet has a space station (required for ship production)
                if not template.is_station and not self.selected_planet.has_station:
                    continue

                # Calculate position with proper spacing
                col = i % 2
                row = i // 2
                button_rect = pygame.Rect(
                    start_x + col * (button_width + button_spacing),
                    start_y + row * (button_height + button_spacing),
                    button_width,
                    button_height
                )

                # Button colors
                if template.cost > self.player_resources:
                    color = (*DARK_RED, 200)
                    text_color = (*LIGHT_BLUE, 150)  # Grayed out text
                else:
                    color = (*DARK_BLUE, 200)
                    text_color = WHITE

                # Truncate name if too long
                display_name = template.name
                if len(display_name) > 12:
                    display_name = display_name[:10] + "..."

                self.production_buttons.append({
                    "rect": button_rect,
                    "unit_type": unit_type,
                    "color": color,
                    "text": f"{display_name} ({template.cost})",
                    "text_color": text_color,
                    "full_name": template.name
                })
        except Exception as e:
            logging.error(f"_create_production_buttons error: {str(e)}")
            self.production_buttons = []

    def _show_research_menu(self):
        """Show research menu with error handling"""
        try:
            if not self.selected_planet or self.selected_planet.owner != 0:
                return

            # Check if player has a research station
            has_research_station = any(p.has_research_station for p in self.planets if p.owner == 0)
            if not has_research_station:
                # Show error message
                error_panel = pygame.Surface((400, 100), pygame.SRCALPHA)
                pygame.draw.rect(error_panel, (*DARK_BLUE, 200), (0, 0, 400, 100), border_radius=10)
                pygame.draw.rect(error_panel, (255, 255, 255, 50), (0, 0, 400, 100), 2, border_radius=10)

                error_text = self.font.render("Research requires a Research Station", True, RED)
                close_text = self.font.render("Click to close", True, WHITE)

                error_panel.blit(error_text, (200 - error_text.get_width() // 2, 30))
                error_panel.blit(close_text, (200 - close_text.get_width() // 2, 60))

                # Show panel and wait for click
                self.screen.blit(error_panel, (SCREEN_WIDTH // 2 - 200, SCREEN_HEIGHT // 2 - 50))
                pygame.display.flip()

                waiting = True
                while waiting:
                    for event in pygame.event.get():
                        if event.type == pygame.QUIT:
                            waiting = False
                            self.running = False
                        elif event.type == pygame.MOUSEBUTTONDOWN:
                            waiting = False
                return

            # Create research menu surface
            menu_width = 400
            menu_height = 300
            menu = pygame.Surface((menu_width, menu_height), pygame.SRCALPHA)
            pygame.draw.rect(menu, (*DARK_BLUE, 200), (0, 0, menu_width, menu_height), border_radius=10)
            pygame.draw.rect(menu, (255, 255, 255, 50), (0, 0, menu_width, menu_height), 2, border_radius=10)

            # Add title
            title = self.font.render("Research Technology", True, WHITE)
            menu.blit(title, (menu_width // 2 - title.get_width() // 2, 20))

            # Add available research options
            y_offset = 60
            for tech in ["fighters", "bombers", "cruisers", "capital_ships", "research_station", "trade_station"]:
                # Skip if already researched
                if self.tech_tree.tech_levels[tech] >= 1:
                    continue

                # Check if requirements are met
                if not self.tech_tree.can_research(tech):
                    continue

                # Check if already researching
                researching = self.tech_tree.research_progress[tech] > 0

                # Create button
                button_rect = pygame.Rect(50, y_offset, menu_width - 100, 40)
                color = (0, 100, 200) if not researching else (100, 100, 100)
                pygame.draw.rect(menu, (*color, 200), button_rect, border_radius=5)
                pygame.draw.rect(menu, (255, 255, 255, 50), button_rect, 1, border_radius=5)

                # Add text
                tech_name = tech.replace("_", " ").title()
                cost = self.tech_tree.research_costs[tech]
                text = self.font.render(f"{tech_name} ({cost} credits)", True, WHITE)
                menu.blit(text, (menu_width // 2 - text.get_width() // 2, y_offset + 10))

                # Add researching indicator
                if researching:
                    progress = self.tech_tree.research_progress[tech]
                    progress_text = self.font.render(f"{int(progress)}%", True, YELLOW)
                    menu.blit(progress_text, (menu_width - 80, y_offset + 10))

                y_offset += 50

            # Add close button
            close_rect = pygame.Rect(menu_width - 40, 10, 30, 30)
            pygame.draw.rect(menu, (200, 50, 50), close_rect, border_radius=5)
            pygame.draw.rect(menu, (255, 255, 255, 50), close_rect, 1, border_radius=5)
            close_text = self.font.render("X", True, WHITE)
            menu.blit(close_text, (menu_width - 30, 15))

            # Show menu and wait for selection
            menu_active = True
            while menu_active:
                mouse_pos = pygame.mouse.get_pos()
                menu_x = SCREEN_WIDTH // 2 - menu_width // 2
                menu_y = SCREEN_HEIGHT // 2 - menu_height // 2

                for event in pygame.event.get():
                    if event.type == pygame.QUIT:
                        menu_active = False
                        self.running = False
                    elif event.type == pygame.MOUSEBUTTONDOWN:
                        if event.button == 1:
                            # Check if clicked on close button
                            if (menu_x + menu_width - 40 <= mouse_pos[0] <= menu_x + menu_width - 10 and
                                    menu_y + 10 <= mouse_pos[1] <= menu_y + 40):
                                menu_active = False

                            # Check research options
                            y_offset = 60
                            for tech in ["fighters", "bombers", "cruisers", "capital_ships", "research_station",
                                         "trade_station"]:
                                # Skip if already researched
                                if self.tech_tree.tech_levels[tech] >= 1:
                                    continue

                                # Check if requirements are met
                                if not self.tech_tree.can_research(tech):
                                    continue

                                # Check if clicked on this option
                                button_rect = pygame.Rect(menu_x + 50, menu_y + y_offset, menu_width - 100, 40)
                                if button_rect.collidepoint(mouse_pos):
                                    if self.tech_tree.start_research(tech, self.player_resources):
                                        self.player_resources -= self.tech_tree.research_costs[tech]
                                    menu_active = False
                                    break

                                y_offset += 50

                # Draw menu
                self.screen.blit(menu, (menu_x, menu_y))
                pygame.display.flip()
                self.clock.tick(FPS)
        except Exception as e:
            logging.error(f"_show_research_menu error: {str(e)}")
            traceback.print_exc()

    def _handle_planet_selection(self, mouse_pos):
        """Handle planet selection with error handling"""
        try:
            for planet in self.planets:
                planet.selected = False

            for planet in self.planets:
                if math.sqrt((planet.x - mouse_pos[0]) ** 2 + (planet.y - mouse_pos[1]) ** 2) < planet.radius:
                    planet.selected = True
                    self.selected_planet = planet
                    logging.debug(f"Selected planet: {planet.name}")
                    break
        except Exception as e:
            logging.error(f"_handle_planet_selection error: {str(e)}")

    def _handle_fleet_movement(self, mouse_pos):
        """Handle fleet movement with error handling"""
        try:
            if not self.selected_planet or self.selected_planet.owner != 0 or not self.selected_planet.fleet:
                return  # Only player can send fleets, and must have ships

            target_planet = None
            for planet in self.planets:
                dist = math.sqrt((planet.x - mouse_pos[0]) ** 2 + (planet.y - mouse_pos[1]) ** 2)
                if (dist < planet.radius and planet != self.selected_planet and
                        planet in self.selected_planet.connected_planets):
                    target_planet = planet
                    break

            if target_planet:
                # Create new fleet movement
                new_fleet = FleetMovement(
                    self.selected_planet,
                    target_planet,
                    self.selected_planet.fleet.copy(),
                    self.selected_planet.owner
                )
                self.fleets_in_transit.append(new_fleet)
                logging.info(f"Sent fleet from {self.selected_planet.name} to {target_planet.name}")

                # Remove units from source planet
                self.selected_planet.fleet = []
        except Exception as e:
            logging.error(f"_handle_fleet_movement error: {str(e)}")

    def _handle_box_selection(self, start_pos, end_pos):
        """Handle box selection with error handling"""
        try:
            # Clear current selection
            for unit in self.battle_units:
                if unit.owner == 0:
                    unit.selected = False

            # Create selection rectangle
            x1 = min(start_pos[0], end_pos[0])
            y1 = min(start_pos[1], end_pos[1])
            x2 = max(start_pos[0], end_pos[0])
            y2 = max(start_pos[1], end_pos[1])
            self.selection_rect = pygame.Rect(x1, y1, x2 - x1, y2 - y1)

            # Select units within rectangle
            for unit in self.battle_units:
                if unit.owner == 0:  # Only player units can be selected
                    if (x1 <= unit.x <= x2 and y1 <= unit.y <= y2):
                        unit.selected = True

            logging.debug(f"Box selection: {len([u for u in self.battle_units if u.selected])} units selected")
        except Exception as e:
            logging.error(f"_handle_box_selection error: {str(e)}")

    def _handle_unit_selection(self, mouse_pos):
        """Handle unit selection with error handling"""
        try:
            shift_pressed = pygame.key.get_pressed()[pygame.K_LSHIFT]

            if not shift_pressed:
                for unit in self.battle_units:
                    unit.selected = False

            for unit in self.battle_units:
                if unit.owner == 0:  # Only player can select
                    screen_x = unit.x - self.camera_x
                    screen_y = unit.y - self.camera_y
                    dist = math.sqrt((screen_x - mouse_pos[0]) ** 2 + (screen_y - mouse_pos[1]) ** 2)
                    if dist < unit.radius:
                        unit.selected = True

            logging.debug(f"Unit selection: {len([u for u in self.battle_units if u.selected])} units selected")
        except Exception as e:
            logging.error(f"_handle_unit_selection error: {str(e)}")

    def _handle_unit_commands(self, mouse_pos):
        """Handle unit commands with error handling"""
        try:
            target_x = mouse_pos[0] + self.camera_x
            target_y = mouse_pos[1] + self.camera_y

            # Check if clicking on an enemy unit
            clicked_enemy = None
            for unit in self.battle_units:
                if unit.owner != 0:  # Enemy unit
                    screen_x = unit.x - self.camera_x
                    screen_y = unit.y - self.camera_y
                    dist = math.sqrt((screen_x - mouse_pos[0]) ** 2 + (screen_y - mouse_pos[1]) ** 2)
                    if dist < unit.radius:
                        clicked_enemy = unit
                        break

            for unit in self.battle_units:
                if unit.selected and unit.owner == 0 and not unit.is_station and not unit.is_research_station and not unit.is_trade_station:  # Can't move stations
                    if clicked_enemy:
                        # Set this enemy as the target
                        unit.target_unit = clicked_enemy
                        logging.debug(f"Unit targeting enemy at ({clicked_enemy.x:.1f}, {clicked_enemy.y:.1f})")
                    else:
                        # Move to position
                        unit.target_x = target_x
                        unit.target_y = target_y
                        unit.target_unit = None  # Clear any previous attack target
                        logging.debug(f"Unit moving to ({target_x:.1f}, {target_y:.1f})")
        except Exception as e:
            logging.error(f"_handle_unit_commands error: {str(e)}")

    def _handle_fleet_arrival(self, fleet: FleetMovement):
        """Handle fleet arrival with error handling"""
        try:
            logging.info(f"Fleet arrived at {fleet.target.name}")
            if fleet.target.owner == fleet.owner or fleet.target.owner == -1:
                # Friendly or neutral planet - just add fleet
                fleet.target.fleet.extend([
                    Unit(
                        fleet.target.x + random.uniform(-20, 20),
                        fleet.target.y + random.uniform(-20, 20),
                        unit.type,
                        fleet.owner
                    )
                    for unit in fleet.units
                ])
                if fleet.target.owner == -1:
                    fleet.target.owner = fleet.owner  # Capture neutral planet
                    logging.info(f"Captured neutral planet {fleet.target.name}")
            else:
                # Enemy planet - start battle
                self._start_battle(fleet.units, fleet.target)

            # Check victory conditions after fleet arrival
            self._check_victory_conditions()
        except Exception as e:
            logging.error(f"_handle_fleet_arrival error: {str(e)}")
            traceback.print_exc()

    def _ai_send_fleet(self):
        """AI fleet management - infrastructure-first with balanced expansion"""
        try:
            # Don't attack until we have at least one research station
            if not self._ai_has_research_station():
                if DEBUG_MODE:
                    logging.debug("AI waiting to build Research Station before attacking")
                return

            # Get planet lists
            ai_planets = [p for p in self.planets if p.owner == 1]
            enemy_planets = [p for p in self.planets if p.owner == 0]
            neutral_planets = [p for p in self.planets if p.owner == -1]

            # Check infrastructure requirements
            developed_planets = [
                p for p in ai_planets
                if p.has_station and p.has_trade_station
            ]

            # Phase 1: Expansion from developed planets only
            if developed_planets:
                for planet in developed_planets:
                    if not planet.fleet:
                        continue

                    # Find connected neutral planets
                    neutral_targets = [
                        p for p in planet.connected_planets
                        if p.owner == -1 and not p.has_station
                    ]

                    if neutral_targets:
                        # Target closest neutral
                        target = min(neutral_targets,
                                     key=lambda p: math.dist((p.x, p.y), (planet.x, planet.y)))

                        # Send small force (25-50% of fleet)
                        send_count = max(2, min(len(planet.fleet) // 2, len(planet.fleet) - 3))

                        logging.info(f"AI expanding to {target.name} from {planet.name}")
                        self.fleets_in_transit.append(FleetMovement(
                            planet, target, planet.fleet[:send_count], planet.owner
                        ))
                        planet.fleet = planet.fleet[send_count:]
                        return  # One expansion per cycle

            # Phase 2: Consolidation from developed planets
            if len(developed_planets) >= 2:
                # Find frontline planet (closest to enemy)
                frontline = min(developed_planets,
                                key=lambda p: min((math.dist((p.x, p.y), (e.x, e.y))
                                                   for e in enemy_planets), default=float('inf')))

                # Consolidate from other developed planets
                for planet in [p for p in developed_planets if p != frontline and p.fleet]:
                    if len(planet.fleet) > 4:  # Leave minimum defense
                        send_count = len(planet.fleet) - 2  # Leave 2 ships
                        if send_count > 0:
                            logging.info(f"AI consolidating to {frontline.name} from {planet.name}")
                            self.fleets_in_transit.append(FleetMovement(
                                planet, frontline, planet.fleet[:send_count], planet.owner
                            ))
                            planet.fleet = planet.fleet[send_count:]
                            return

            # Phase 3: Attack from frontline if conditions met
            frontline = min((p for p in developed_planets if p.fleet),
                            key=lambda p: min((math.dist((p.x, p.y), (e.x, e.y))
                                               for e in enemy_planets), default=float('inf')),
                            default=None)

            if frontline:
                enemy_targets = [
                                    p for p in frontline.connected_planets
                                    if p.owner == 0 and p.has_station  # Target enemy developed planets first
                                ] or [p for p in frontline.connected_planets if p.owner == 0]

                if enemy_targets:
                    target = min(enemy_targets, key=lambda p: len(p.fleet))
                    if len(frontline.fleet) >= max(3, len(target.fleet) * 1.8):
                        logging.info(f"AI attacking {target.name} from {frontline.name}")
                        self.fleets_in_transit.append(FleetMovement(
                            frontline, target, frontline.fleet.copy(), frontline.owner
                        ))
                        frontline.fleet = []

        except Exception as e:
            logging.error(f"_ai_send_fleet error: {str(e)}")
            traceback.print_exc()

    def _find_path_to_planet(self, start_planet, target_planet, max_depth=10):
        """Find path between planets using BFS with same owner"""
        try:
            from collections import deque

            visited = set()
            queue = deque()
            queue.append((start_planet, []))  # (current_planet, path)

            while queue:
                current, path = queue.popleft()

                if current == target_planet:
                    return path

                if len(path) >= max_depth:
                    continue

                for neighbor in current.connected_planets:
                    if neighbor not in visited and neighbor.owner == 1:  # Only move through AI territory
                        visited.add(neighbor)
                        new_path = path.copy()
                        if neighbor != start_planet:  # Don't include start planet in path
                            new_path.append(neighbor)
                        queue.append((neighbor, new_path))

            return None  # No path found within max depth
        except Exception as e:
            logging.error(f"_find_path_to_planet error: {str(e)}")
            return None



    def _ai_has_research_station(self):
        """Check if AI has at least one operational research station"""
        return any(p.has_research_station and p.owner == 1 for p in self.planets)

    def _ai_manage_production(self):
        """AI production management - now with weighted random ship selection"""
        try:
            # 10-second cooldown between production attempts
            current_time = pygame.time.get_ticks()
            if hasattr(self, '_last_ai_production_time'):
                if current_time - self._last_ai_production_time < 10000:  # 10 seconds
                    return

            # Find available planets (no current production)
            ai_planets = [p for p in self.planets if p.owner == 1 and not p.current_production]
            if not ai_planets:
                return

            # Check infrastructure requirements
            has_research_station = self._ai_has_research_station()
            all_have_space_stations = all(p.has_station for p in self.planets if p.owner == 1)
            all_have_trade_stations = all(p.has_trade_station for p in self.planets if p.owner == 1)

            # PHASE 1: BUILD MISSING INFRASTRUCTURE
            if not has_research_station or not all_have_space_stations or not all_have_trade_stations:
                for planet in ai_planets:
                    # 1. Build Research Station if none exists (only need one)
                    if (not has_research_station and
                            not planet.has_research_station and
                            self.ai_resources >= UNIT_TEMPLATES[UnitType.RESEARCH_STATION].cost):
                        planet.current_production[UnitType.RESEARCH_STATION.name] = 0.0
                        self.ai_resources -= UNIT_TEMPLATES[UnitType.RESEARCH_STATION].cost
                        self._last_ai_production_time = current_time
                        logging.info(f"AI building Research Station on {planet.name}")
                        return

                    # 2. Build Space Station if missing
                    if (not planet.has_station and
                            self.ai_resources >= UNIT_TEMPLATES[UnitType.SPACE_STATION].cost):
                        planet.current_production[UnitType.SPACE_STATION.name] = 0.0
                        self.ai_resources -= UNIT_TEMPLATES[UnitType.SPACE_STATION].cost
                        self._last_ai_production_time = current_time
                        logging.info(f"AI building Space Station on {planet.name}")
                        return

                    # 3. Build Trade Station if missing
                    if (not planet.has_trade_station and
                            self.ai_resources >= UNIT_TEMPLATES[UnitType.TRADE_STATION].cost):
                        planet.current_production[UnitType.TRADE_STATION.name] = 0.0
                        self.ai_resources -= UNIT_TEMPLATES[UnitType.TRADE_STATION].cost
                        self._last_ai_production_time = current_time
                        logging.info(f"AI building Trade Station on {planet.name}")
                        return
                return  # Exit if we're still building infrastructure

            # PHASE 2: MILITARY PRODUCTION (only when requirements met)
            military_ready_planets = [p for p in ai_planets if p.has_station and p.has_trade_station]
            if not military_ready_planets:
                return

            # Choose a random military-ready planet
            planet = random.choice(military_ready_planets)

            # Define ship building priorities with weighted probabilities
            ship_choices = [
                (UnitType.CAPITAL_SHIP, "capital_ships", 0.50),  # 50% chance
                (UnitType.CRUISER, "cruisers", 0.25),  # 25% chance
                (UnitType.BOMBER, "bombers", 0.125),  # 12.5% chance
                (UnitType.FIGHTER, "fighters", 0.125)  # 12.5% chance
            ]

            # Select a ship to build based on weighted probabilities
            rand_val = random.random()
            cumulative_prob = 0
            selected_ship = None
            selected_tech = None

            for ship_type, tech_req, prob in ship_choices:
                cumulative_prob += prob
                if rand_val <= cumulative_prob:
                    selected_ship = ship_type
                    selected_tech = tech_req
                    break

            # Check if we have the required technology
            if not self.ai_tech_tree.tech_levels.get(selected_tech, 0):
                # If not, check if we can research it
                if (self.ai_tech_tree.can_research(selected_tech) and
                        self.ai_resources >= self.ai_tech_tree.research_costs[selected_tech]):

                    # Start researching the required tech
                    if self.ai_tech_tree.start_research(selected_tech, self.ai_resources):
                        self.ai_resources -= self.ai_tech_tree.research_costs[selected_tech]
                        self._last_ai_production_time = current_time
                        logging.info(f"AI researching {selected_tech} for {selected_ship.name}")
                    return
                else:
                    # Can't research yet, save resources
                    logging.debug(f"AI waiting to research {selected_tech} for {selected_ship.name}")
                    return

            # Check if we can afford the selected ship
            ship_cost = UNIT_TEMPLATES[selected_ship].cost
            if self.ai_resources >= ship_cost:
                planet.current_production[selected_ship.name] = 0.0
                self.ai_resources -= ship_cost
                self._last_ai_production_time = current_time
                logging.info(f"AI building {selected_ship.name} on {planet.name}")
            else:
                logging.debug(
                    f"AI saving resources for {selected_ship.name} (cost: {ship_cost}, has: {self.ai_resources})")

        except Exception as e:
            logging.error(f"AI production error: {str(e)}")
            traceback.print_exc()

    def validate_units(self):
        """Validate all units in the game"""
        try:
            # Validate battle units
            for unit in self.battle_units[:]:
                if not (0 <= unit.x <= BATTLE_WIDTH and 0 <= unit.y <= BATTLE_HEIGHT):
                    logging.warning(f"Removing invalid unit at ({unit.x}, {unit.y})")
                    self.battle_units.remove(unit)
                elif unit.health <= 0:
                    logging.debug(f"Removing dead unit at ({unit.x}, {unit.y})")
                    self.battle_units.remove(unit)

            # Validate planet fleets
            for planet in self.planets:
                for unit in planet.fleet[:]:
                    if not (0 <= unit.x <= SCREEN_WIDTH and 0 <= unit.y <= SCREEN_HEIGHT):
                        logging.warning(f"Removing invalid planet unit at ({unit.x}, {unit.y})")
                        planet.fleet.remove(unit)
                    elif unit.health <= 0:
                        logging.debug(f"Removing dead planet unit at ({unit.x}, {unit.y})")
                        planet.fleet.remove(unit)

            # Validate fleets in transit
            for fleet in self.fleets_in_transit[:]:
                for unit in fleet.units[:]:
                    if unit.health <= 0:
                        logging.debug("Removing dead unit from transit fleet")
                        fleet.units.remove(unit)
                if not fleet.units:
                    logging.debug("Removing empty transit fleet")
                    self.fleets_in_transit.remove(fleet)
        except Exception as e:
            logging.error(f"validate_units error: {str(e)}")

    def draw_debug_info(self):
        """Draw debug information on screen"""
        try:
            if not DEBUG_MODE:
                return

            debug_font = pygame.font.Font(None, 24)

            # Basic game info
            info = [
                f"FPS: {int(self.clock.get_fps())}",
                f"State: {self.state.name}",
                f"Day: {self.current_day}",
                f"Player Resources: {self.player_resources}",
                f"AI Resources: {self.ai_resources}",
                f"Units: {len(self.battle_units)}",
                f"Projectiles: {len(self.battle_projectiles)}",
                f"Camera: ({self.camera_x:.1f}, {self.camera_y:.1f})"
            ]

            # Add debug messages
            if self.debug_messages:
                info.extend(self.debug_messages[-3:])  # Show last 3 messages

            # Draw info
            for i, text in enumerate(info):
                text_surface = debug_font.render(text, True, WHITE)
                self.screen.blit(text_surface, (10, 10 + i * 25))

            # Clear debug messages if too many
            if len(self.debug_messages) > 10:
                self.debug_messages = self.debug_messages[-10:]
        except Exception as e:
            logging.error(f"draw_debug_info error: {str(e)}")

    def handle_events(self):
        """Handle all game events with error handling"""
        try:
            current_time = pygame.time.get_ticks()
            dt = (current_time - self.last_time) / 1000.0  # Delta time in seconds
            self.last_time = current_time

            # Update galactic day timer
            self.galactic_day_timer += dt
            if self.galactic_day_timer >= GALACTIC_DAY_DURATION:
                self.galactic_day_timer = 0
                self._collect_galactic_resources()

            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    self.running = False

                # Reset game on any key press when in victory/defeat state
                if event.type == pygame.KEYDOWN and (self.state == GameState.VICTORY or self.state == GameState.DEFEAT):
                    self.__init__()  # Reset the game
                    logging.info("Game reset")

                # Galactic Map Controls
                if self.state == GameState.GALACTIC_MAP:
                    if event.type == pygame.MOUSEBUTTONDOWN:
                        mouse_pos = pygame.mouse.get_pos()

                        # Left click - select planet or production button
                        if event.button == 1:
                            # Check if clicking on a production button first
                            button_clicked = False
                            for button in self.production_buttons:
                                if button["rect"].collidepoint(mouse_pos):
                                    template = UNIT_TEMPLATES[button["unit_type"]]
                                    if template.cost <= self.player_resources:
                                        self.selected_planet.add_to_production_queue(button["unit_type"],
                                                                                     self.player_resources)
                                        self.player_resources -= template.cost
                                        self._create_production_buttons()  # Refresh buttons
                                    button_clicked = True
                                    break

                            if not button_clicked:
                                self._handle_planet_selection(mouse_pos)
                                self._create_production_buttons()

                        # Right click - send fleet
                        elif event.button == 3:
                            self._handle_fleet_movement(mouse_pos)

                    # Production hotkeys
                    elif event.type == pygame.KEYDOWN:
                        if self.selected_planet and self.selected_planet.owner == 0:
                            if event.key == pygame.K_1:
                                if (self.tech_tree.can_build(UnitType.FIGHTER) and
                                        self.selected_planet.add_to_production_queue(UnitType.FIGHTER,
                                                                                     self.player_resources)):
                                    self.player_resources -= UNIT_TEMPLATES[UnitType.FIGHTER].cost
                                    self._create_production_buttons()
                            elif event.key == pygame.K_2:
                                if (self.tech_tree.can_build(UnitType.CRUISER) and
                                        self.selected_planet.add_to_production_queue(UnitType.CRUISER,
                                                                                     self.player_resources)):
                                    self.player_resources -= UNIT_TEMPLATES[UnitType.CRUISER].cost
                                    self._create_production_buttons()
                            elif event.key == pygame.K_3:
                                if (self.tech_tree.can_build(UnitType.CAPITAL_SHIP) and
                                        self.selected_planet.add_to_production_queue(UnitType.CAPITAL_SHIP,
                                                                                     self.player_resources)):
                                    self.player_resources -= UNIT_TEMPLATES[UnitType.CAPITAL_SHIP].cost
                                    self._create_production_buttons()
                            elif event.key == pygame.K_4:
                                if (self.tech_tree.can_build(UnitType.BOMBER) and
                                        self.selected_planet.add_to_production_queue(UnitType.BOMBER,
                                                                                     self.player_resources)):
                                    self.player_resources -= UNIT_TEMPLATES[UnitType.BOMBER].cost
                                    self._create_production_buttons()
                            elif event.key == pygame.K_5:
                                if (self.tech_tree.can_build(UnitType.SPACE_STATION) and
                                        self.selected_planet.add_to_production_queue(UnitType.SPACE_STATION,
                                                                                     self.player_resources)):
                                    self.player_resources -= UNIT_TEMPLATES[UnitType.SPACE_STATION].cost
                                    self._create_production_buttons()
                            elif event.key == pygame.K_6:
                                if (self.tech_tree.can_build(UnitType.RESEARCH_STATION) and
                                        self.selected_planet.add_to_production_queue(UnitType.RESEARCH_STATION,
                                                                                     self.player_resources)):
                                    self.player_resources -= UNIT_TEMPLATES[UnitType.RESEARCH_STATION].cost
                                    self._create_production_buttons()
                            elif event.key == pygame.K_7:
                                if (self.tech_tree.can_build(UnitType.TRADE_STATION) and
                                        self.selected_planet.add_to_production_queue(UnitType.TRADE_STATION,
                                                                                     self.player_resources)):
                                    self.player_resources -= UNIT_TEMPLATES[UnitType.TRADE_STATION].cost
                                    self._create_production_buttons()
                            elif event.key == pygame.K_r:
                                # Show research menu
                                self._show_research_menu()

                # Tactical Battle Controls
                elif self.state == GameState.TACTICAL_BATTLE:
                    if event.type == pygame.MOUSEBUTTONDOWN:
                        mouse_pos = pygame.mouse.get_pos()

                        # Left click - select units or click minimap
                        if event.button == 1:
                            # Check if clicking on minimap
                            if self.minimap.rect.collidepoint(mouse_pos):
                                # Convert minimap click to camera position
                                rel_x = mouse_pos[0] - self.minimap.rect.x
                                rel_y = mouse_pos[1] - self.minimap.rect.y

                                # Calculate battle coordinates
                                battle_x = (rel_x / self.minimap.width) * BATTLE_WIDTH
                                battle_y = (rel_y / self.minimap.height) * BATTLE_HEIGHT

                                # Center camera on clicked position
                                self.camera_x = battle_x - SCREEN_WIDTH // 2
                                self.camera_y = battle_y - SCREEN_HEIGHT // 2
                                self.camera_follow = False

                                # Clamp camera to battle area
                                self.camera_x = max(0, min(BATTLE_WIDTH - SCREEN_WIDTH, self.camera_x))
                                self.camera_y = max(0, min(BATTLE_HEIGHT - SCREEN_HEIGHT, self.camera_y))
                            else:
                                # Start selection box
                                self.selection_start = (
                                    mouse_pos[0] + self.camera_x,
                                    mouse_pos[1] + self.camera_y
                                )

                        # Right click - move/attack
                        elif event.button == 3:
                            self._handle_unit_commands(mouse_pos)

                    elif event.type == pygame.MOUSEBUTTONUP:
                        if event.button == 1 and self.selection_start:
                            # Finish selection box
                            mouse_pos = pygame.mouse.get_pos()
                            selection_end = (
                                mouse_pos[0] + self.camera_x,
                                mouse_pos[1] + self.camera_y
                            )

                            # Select units in box
                            self._handle_box_selection(self.selection_start, selection_end)
                            self.selection_start = None
                            self.selection_rect = None

                    elif event.type == pygame.MOUSEMOTION:
                        if self.selection_start:
                            # Update selection box
                            mouse_pos = pygame.mouse.get_pos()
                            current_pos = (
                                mouse_pos[0] + self.camera_x,
                                mouse_pos[1] + self.camera_y
                            )

                            # Create selection rectangle
                            x1 = min(self.selection_start[0], current_pos[0])
                            y1 = min(self.selection_start[1], current_pos[1])
                            x2 = max(self.selection_start[0], current_pos[0])
                            y2 = max(self.selection_start[1], current_pos[1])
                            self.selection_rect = pygame.Rect(x1, y1, x2 - x1, y2 - y1)

                    elif event.type == pygame.KEYDOWN:
                        if event.key == pygame.K_f:
                            self.camera_follow = not self.camera_follow
        except Exception as e:
            logging.error(f"handle_events error: {str(e)}")
            traceback.print_exc()

    def update(self):
        """Update game state with error handling"""
        try:
            current_time = pygame.time.get_ticks()
            dt = (current_time - self.last_time) / 1000.0  # Delta time in seconds
            self.last_time = current_time
            self.frame_count += 1

            # Skip updates if in victory/defeat state
            if self.state in (GameState.VICTORY, GameState.DEFEAT):
                return

            # Update all planets' production (5x faster)
            for planet in self.planets:
                planet.update_production(dt)

            if self.state == GameState.GALACTIC_MAP:
                # Update fleet movements
                for fleet in self.fleets_in_transit[:]:
                    if fleet.update():  # Returns True when arrival happens
                        self._handle_fleet_arrival(fleet)
                        self.fleets_in_transit.remove(fleet)

                # Simple AI behavior - increased frequency (was 0.001, now 0.005)
                if random.random() < 0.005:
                    self._ai_send_fleet()

                if random.random() < 0.05:  # Increased from 0.01
                    self._ai_manage_production()

            elif self.state == GameState.TACTICAL_BATTLE:
                # Update camera position
                self._update_camera()

                # Update minimap
                self.minimap.update(self.battle_units, self.camera_x, self.camera_y)

                # Update AI unit behavior
                self._update_ai_units()

                # Update units
                for unit in self.battle_units[:]:
                    unit.update(self.battle_units, self.battle_projectiles)
                    if unit.health <= 0:
                        self.battle_units.remove(unit)

                # Update projectiles
                self._update_projectiles()

                # Check battle outcome
                player_units = sum(1 for u in self.battle_units if u.owner == 0)
                ai_units = sum(1 for u in self.battle_units if u.owner == 1)

                if player_units == 0:
                    self._end_battle(1)  # AI wins
                elif ai_units == 0:
                    self._end_battle(0)  # Player wins

                # Periodically validate units
                if self.frame_count % VALIDATE_UNITS_EVERY == 0:
                    self.validate_units()
        except Exception as e:
            logging.error(f"update error: {str(e)}")
            traceback.print_exc()

    def draw(self):
        """Draw game with error handling"""
        try:
            # Draw background
            self.screen.blit(self.background_gradient, (0, 0))
            self.screen.blit(self.starfield, (0, 0))

            if self.state == GameState.GALACTIC_MAP:
                self._draw_galactic_map()
            elif self.state == GameState.TACTICAL_BATTLE:
                self._draw_tactical_battle()
            elif self.state == GameState.VICTORY:
                self._draw_victory_screen()
            elif self.state == GameState.DEFEAT:
                self._draw_defeat_screen()

            # Draw debug info if enabled
            if DEBUG_MODE:
                self.draw_debug_info()

            pygame.display.flip()
        except Exception as e:
            logging.error(f"draw error: {str(e)}")
            traceback.print_exc()

    def _draw_galactic_map(self):
        """Draw galactic map with error handling"""
        try:
            # Draw fleet movement lines
            for fleet in self.fleets_in_transit:
                fleet.draw(self.screen)

            # Draw planets
            for planet in self.planets:
                planet.draw(self.screen)

            # Draw UI
            self._draw_galactic_ui()
        except Exception as e:
            logging.error(f"_draw_galactic_map error: {str(e)}")

    def _draw_galactic_ui(self):
        """Draw galactic UI with error handling"""
        try:
            # Draw glass panel for resources
            resource_panel = pygame.Surface((300, 80), pygame.SRCALPHA)
            pygame.draw.rect(resource_panel, (*DARK_BLUE, 180), (0, 0, 300, 80), border_radius=10)
            pygame.draw.rect(resource_panel, (255, 255, 255, 50), (0, 0, 300, 80), 2, border_radius=10)
            self.screen.blit(resource_panel, (20, 20))

            # Draw resource text with shadow
            resource_text = self.font.render(f"Credits: {self.player_resources}", True, WHITE)
            resource_shadow = self.font.render(f"Credits: {self.player_resources}", True, BLACK)

            day_text = self.font.render(
                f"Day {self.current_day} (Next: {int(GALACTIC_DAY_DURATION - self.galactic_day_timer)}s)", True, WHITE)
            day_shadow = self.font.render(
                f"Day {self.current_day} (Next: {int(GALACTIC_DAY_DURATION - self.galactic_day_timer)}s)", True, BLACK)

            # Draw shadows
            for offset in [(1, 1), (-1, -1), (1, -1), (-1, 1)]:
                self.screen.blit(day_shadow, (30 + offset[0], 60 + offset[1]))
                self.screen.blit(resource_shadow, (30 + offset[0], 30 + offset[1]))

            # Draw main text
            self.screen.blit(resource_text, (30, 30))
            self.screen.blit(day_text, (30, 60))

            # Draw tech tree status
            tech_panel = pygame.Surface((400, 120), pygame.SRCALPHA)
            pygame.draw.rect(tech_panel, (*DARK_BLUE, 180), (0, 0, 400, 120), border_radius=10)
            pygame.draw.rect(tech_panel, (255, 255, 255, 50), (0, 0, 400, 120), 2, border_radius=10)
            self.screen.blit(tech_panel, (SCREEN_WIDTH - 420, 20))

            tech_text = self.font.render("Tech Levels:", True, WHITE)
            self.screen.blit(tech_text, (SCREEN_WIDTH - 410, 30))

            fighter_tech = self.font.render(f"Fighters: {self.tech_tree.tech_levels['fighters']}", True, WHITE)
            bomber_tech = self.font.render(f"Bombers: {self.tech_tree.tech_levels['bombers']}", True, WHITE)
            cruiser_tech = self.font.render(f"Cruisers: {self.tech_tree.tech_levels['cruisers']}", True, WHITE)
            capital_tech = self.font.render(f"Capital: {self.tech_tree.tech_levels['capital_ships']}", True, WHITE)
            station_tech = self.font.render(f"Stations: {self.tech_tree.tech_levels['stations']}", True, WHITE)
            research_tech = self.font.render(f"Research: {self.tech_tree.tech_levels['research_station']}", True, WHITE)
            trade_tech = self.font.render(f"Trade: {self.tech_tree.tech_levels['trade_station']}", True, WHITE)

            self.screen.blit(fighter_tech, (SCREEN_WIDTH - 410, 50))
            self.screen.blit(bomber_tech, (SCREEN_WIDTH - 410, 70))
            self.screen.blit(cruiser_tech, (SCREEN_WIDTH - 410, 90))
            self.screen.blit(capital_tech, (SCREEN_WIDTH - 280, 50))
            self.screen.blit(station_tech, (SCREEN_WIDTH - 280, 70))
            self.screen.blit(research_tech, (SCREEN_WIDTH - 280, 90))
            self.screen.blit(trade_tech, (SCREEN_WIDTH - 280, 110))

            # Draw research progress if any
            for tech, progress in self.tech_tree.research_progress.items():
                if progress > 0 and progress < 100:
                    research_text = self.font.render(f"Researching {tech}: {int(progress)}%", True, YELLOW)
                    self.screen.blit(research_text, (SCREEN_WIDTH - 410, 110))
                    break

            # Draw production buttons if planet selected
            if self.selected_planet and self.selected_planet.owner == 0:
                # Draw production panel
                panel_rect = pygame.Rect(50, SCREEN_HEIGHT - 250, 400, 200)  # Increased height
                glass = pygame.Surface((panel_rect.width, panel_rect.height), pygame.SRCALPHA)
                pygame.draw.rect(glass, (*DARK_BLUE, 180), (0, 0, panel_rect.width, panel_rect.height),
                                 border_radius=10)
                pygame.draw.rect(glass, (255, 255, 255, 30), (0, 0, panel_rect.width, panel_rect.height), 2,
                                 border_radius=10)
                self.screen.blit(glass, panel_rect)

                # Draw title
                title = self.font.render(f"{self.selected_planet.name} Production", True, WHITE)
                self.screen.blit(title, (panel_rect.x + 15, panel_rect.y + 15))

                # Draw buttons
                for button in self.production_buttons:
                    pygame.draw.rect(self.screen, button["color"], button["rect"], border_radius=5)
                    pygame.draw.rect(self.screen, (255, 255, 255, 50), button["rect"], 1, border_radius=5)

                    # Draw button text
                    text = self.button_font.render(button["text"], True, button["text_color"])
                    text_rect = text.get_rect(center=button["rect"].center)
                    self.screen.blit(text, text_rect)

                    # Show full name as tooltip if mouse is hovering
                    mouse_pos = pygame.mouse.get_pos()
                    if button["rect"].collidepoint(mouse_pos):
                        tooltip = self.font.render(button["full_name"], True, WHITE)
                        tooltip_rect = pygame.Rect(
                            mouse_pos[0] + 10,
                            mouse_pos[1] + 10,
                            tooltip.get_width() + 10,
                            tooltip.get_height() + 10
                        )
                        pygame.draw.rect(self.screen, (*DARK_BLUE, 220), tooltip_rect, border_radius=5)
                        pygame.draw.rect(self.screen, (255, 255, 255, 50), tooltip_rect, 1, border_radius=5)
                        self.screen.blit(tooltip, (mouse_pos[0] + 15, mouse_pos[1] + 15))

                # Draw current production
                y_offset = 50
                for unit_type, progress in self.selected_planet.current_production.items():
                    template = UNIT_TEMPLATES[UnitType[unit_type]]
                    progress_percent = min(100, int(progress / template.build_time * 100))

                    # Progress bar background
                    pygame.draw.rect(self.screen, (*BLACK, 150),
                                     (panel_rect.x + 15, panel_rect.y + y_offset + 15, 200, 10))

                    # Progress bar fill
                    pygame.draw.rect(self.screen, GREEN,
                                     (
                                     panel_rect.x + 15, panel_rect.y + y_offset + 15, 200 * progress_percent / 100, 10))

                    text = self.font.render(f"{template.name}: {progress_percent}%", True, WHITE)
                    self.screen.blit(text, (panel_rect.x + 15, panel_rect.y + y_offset))
                    y_offset += 35

            # Draw help text
            help_panel = pygame.Surface((600, 40), pygame.SRCALPHA)
            pygame.draw.rect(help_panel, (*DARK_BLUE, 180), (0, 0, 600, 40), border_radius=10)
            pygame.draw.rect(help_panel, (255, 255, 255, 50), (0, 0, 600, 40), 2, border_radius=10)
            self.screen.blit(help_panel, (SCREEN_WIDTH // 2 - 300, SCREEN_HEIGHT - 50))

            help_text = self.font.render(
                "Left-click planet, Right-click to send fleet | 1-7: Build ships/stations | R: Research",
                True, WHITE
            )
            self.screen.blit(help_text, (SCREEN_WIDTH // 2 - help_text.get_width() // 2, SCREEN_HEIGHT - 40))
        except Exception as e:
            logging.error(f"_draw_galactic_ui error: {str(e)}")

    def _draw_tactical_battle(self):
        """Draw tactical battle with error handling"""
        try:
            # Draw battle background with nebula effect
            self.screen.blit(self.background_gradient, (-self.camera_x, -self.camera_y))
            self.screen.blit(self.starfield, (-self.camera_x, -self.camera_y))

            # Draw planet name
            if self.current_battle_planet:
                name_panel = pygame.Surface((400, 50), pygame.SRCALPHA)
                pygame.draw.rect(name_panel, (*DARK_BLUE, 200), (0, 0, 400, 50), border_radius=10)
                pygame.draw.rect(name_panel, (255, 255, 255, 50), (0, 0, 400, 50), 2, border_radius=10)
                self.screen.blit(name_panel, (SCREEN_WIDTH // 2 - 200, 20))

                planet_text = self.title_font.render(
                    f"Battle for {self.current_battle_planet.name}",
                    True, YELLOW
                )
                self.screen.blit(planet_text, (SCREEN_WIDTH // 2 - planet_text.get_width() // 2, 30))

            # Draw enemy spawn point indicator
            pygame.draw.circle(self.screen, (*RED, 100),
                               (int(self.enemy_spawn_point[0] - self.camera_x),
                                int(self.enemy_spawn_point[1] - self.camera_y)),
                               50, 2)

            # Draw projectiles first (so they appear under ships)
            for proj in self.battle_projectiles:
                proj.draw(self.screen, self.camera_x, self.camera_y)

            # Draw units
            for unit in self.battle_units:
                unit.draw(self.screen, self.camera_x, self.camera_y)

            # Draw selection box if active
            if self.selection_rect:
                screen_rect = pygame.Rect(
                    self.selection_rect.x - self.camera_x,
                    self.selection_rect.y - self.camera_y,
                    self.selection_rect.width,
                    self.selection_rect.height
                )
                pygame.draw.rect(self.screen, (0, 255, 0, 100), screen_rect, 2)

            # Draw minimap
            self.minimap.draw(self.screen)

            # Draw battle UI
            self._draw_battle_ui()
        except Exception as e:
            logging.error(f"_draw_tactical_battle error: {str(e)}")

    def _draw_battle_ui(self):
        """Draw battle UI with error handling"""
        try:
            # Draw force counters
            player_count = sum(1 for u in self.battle_units if u.owner == 0)
            ai_count = sum(1 for u in self.battle_units if u.owner == 1)

            # Player panel
            player_panel = pygame.Surface((200, 50), pygame.SRCALPHA)
            pygame.draw.rect(player_panel, (*DARK_BLUE, 180), (0, 0, 200, 50), border_radius=10)
            pygame.draw.rect(player_panel, (255, 255, 255, 50), (0, 0, 200, 50), 2, border_radius=10)
            self.screen.blit(player_panel, (50, 50))

            player_text = self.font.render(f"Player Forces: {player_count}", True, BLUE)
            self.screen.blit(player_text, (60, 65))

            # AI panel
            ai_panel = pygame.Surface((200, 50), pygame.SRCALPHA)
            pygame.draw.rect(ai_panel, (*DARK_BLUE, 180), (0, 0, 200, 50), border_radius=10)
            pygame.draw.rect(ai_panel, (255, 255, 255, 50), (0, 0, 200, 50), 2, border_radius=10)
            self.screen.blit(ai_panel, (SCREEN_WIDTH - 250, 50))

            ai_text = self.font.render(f"Enemy Forces: {ai_count}", True, RED)
            self.screen.blit(ai_text, (SCREEN_WIDTH - 240, 65))

            # Camera mode indicator
            camera_panel = pygame.Surface((200, 30), pygame.SRCALPHA)
            pygame.draw.rect(camera_panel, (*DARK_BLUE, 180), (0, 0, 200, 30), border_radius=5)
            pygame.draw.rect(camera_panel, (255, 255, 255, 50), (0, 0, 200, 30), 1, border_radius=5)
            self.screen.blit(camera_panel, (SCREEN_WIDTH // 2 - 100, 20))

            camera_text = self.font.render(
                f"Camera: {'Follow' if self.camera_follow else 'Free'}",
                True, WHITE
            )
            self.screen.blit(camera_text, (SCREEN_WIDTH // 2 - camera_text.get_width() // 2, 25))

            # Help panel
            help_panel = pygame.Surface((500, 40), pygame.SRCALPHA)
            pygame.draw.rect(help_panel, (*DARK_BLUE, 180), (0, 0, 500, 40), border_radius=10)
            pygame.draw.rect(help_panel, (255, 255, 255, 50), (0, 0, 500, 40), 2, border_radius=10)
            self.screen.blit(help_panel, (SCREEN_WIDTH // 2 - 250, SCREEN_HEIGHT - 50))

            help_text = self.font.render(
                "Left-click units, Right-click to move/attack | Arrow keys: Move camera | F: Toggle follow | Click minimap to jump",
                True, WHITE
            )
            self.screen.blit(help_text, (SCREEN_WIDTH // 2 - help_text.get_width() // 2, SCREEN_HEIGHT - 40))

            # Add targeting instructions
            target_help = self.font.render("Right-click enemy to attack it", True, YELLOW)
            self.screen.blit(target_help, (SCREEN_WIDTH // 2 - target_help.get_width() // 2, SCREEN_HEIGHT - 80))

            # Add selection box instructions
            if self.selection_start:
                box_help = self.font.render("Drag to select multiple units", True, YELLOW)
                self.screen.blit(box_help, (SCREEN_WIDTH // 2 - box_help.get_width() // 2, SCREEN_HEIGHT - 110))
        except Exception as e:
            logging.error(f"_draw_battle_ui error: {str(e)}")

    def _draw_victory_screen(self):
        """Draw victory screen with error handling"""
        try:
            overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
            overlay.fill((0, 0, 0, 200))
            self.screen.blit(overlay, (0, 0))

            victory_text = self.victory_font.render("VICTORY!", True, YELLOW)
            instruction_text = self.font.render("Press any key to play again", True, WHITE)

            self.screen.blit(victory_text,
                             (SCREEN_WIDTH // 2 - victory_text.get_width() // 2,
                              SCREEN_HEIGHT // 2 - victory_text.get_height() // 2))
            self.screen.blit(instruction_text,
                             (SCREEN_WIDTH // 2 - instruction_text.get_width() // 2,
                              SCREEN_HEIGHT // 2 + 100))
        except Exception as e:
            logging.error(f"_draw_victory_screen error: {str(e)}")

    def _draw_defeat_screen(self):
        """Draw defeat screen with error handling"""
        try:
            overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
            overlay.fill((0, 0, 0, 200))
            self.screen.blit(overlay, (0, 0))

            defeat_text = self.victory_font.render("DEFEAT", True, RED)
            instruction_text = self.font.render("Press any key to play again", True, WHITE)

            self.screen.blit(defeat_text,
                             (SCREEN_WIDTH // 2 - defeat_text.get_width() // 2,
                              SCREEN_HEIGHT // 2 - defeat_text.get_height() // 2))
            self.screen.blit(instruction_text,
                             (SCREEN_WIDTH // 2 - instruction_text.get_width() // 2,
                              SCREEN_HEIGHT // 2 + 100))
        except Exception as e:
            logging.error(f"_draw_defeat_screen error: {str(e)}")

    def run(self):
        """Main game loop with error handling"""
        try:
            while self.running:
                self.clock.tick(FPS)
                self.handle_events()
                self.update()
                self.draw()

                # Print debug info to console periodically
                if DEBUG_MODE and self.frame_count % 60 == 0:
                    print(f"FPS: {self.clock.get_fps():.1f} | Units: {len(self.battle_units)} | "
                          f"Projectiles: {len(self.battle_projectiles)} | "
                          f"Camera: ({self.camera_x:.1f}, {self.camera_y:.1f})")

            pygame.quit()
            logging.info("Game exited normally")
        except Exception as e:
            logging.critical(f"Game crashed: {str(e)}")
            traceback.print_exc()
            pygame.quit()


# Run the game
if __name__ == "__main__":
    try:
        logging.info("Starting Empire at War")
        game = EmpireAtWarGame()
        game.run()
    except Exception as e:
        logging.critical(f"Fatal error: {str(e)}")
        traceback.print_exc()
